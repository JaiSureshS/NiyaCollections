(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[179],{612:module=>{eval("/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEyLmpzIiwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInNlbGYiLCJGb3JtRGF0YSIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzPzVhMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQUEsTUFBTSxDQUFDQyxPQUFPLEdBQUcsT0FBT0MsSUFBSSxJQUFJLFFBQVEsR0FBR0EsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLE1BQU0sQ0FBQ0QsUUFBUSJ9\n//# sourceURL=webpack-internal:///612\n")},452:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {\n  toString: utils_toString\n} = Object.prototype;\nconst {\n  getPrototypeOf\n} = Object;\nconst kindOf = (cache => thing => {\n  const str = utils_toString.call(thing);\n  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\nconst kindOfTest = type => {\n  type = type.toLowerCase();\n  return thing => kindOf(thing) === type;\n};\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {\n  isArray\n} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest(\'undefined\');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest(\'ArrayBuffer\');\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if (typeof ArrayBuffer !== \'undefined\' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest(\'string\');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest(\'function\');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest(\'number\');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = thing => thing !== null && typeof thing === \'object\';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = val => {\n  if (kindOf(val) !== \'object\') {\n    return false;\n  }\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest(\'Date\');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest(\'File\');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest(\'Blob\');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest(\'FileList\');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = val => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = thing => {\n  const pattern = \'[object FormData]\';\n  return thing && (typeof FormData === \'function\' && thing instanceof FormData || utils_toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest(\'URLSearchParams\');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = str => str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \'\');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If \'obj\' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {void}\n */\nfunction forEach(obj, fn, {\n  allOwnKeys = false\n} = {}) {\n  // Don\'t bother if no value provided\n  if (obj === null || typeof obj === \'undefined\') {\n    return;\n  }\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== \'object\') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge( /* obj1, obj2, obj3, ... */\n) {\n  const result = {};\n  const assignValue = (val, key) => {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  };\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {\n  allOwnKeys\n} = {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {\n    allOwnKeys\n  });\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = content => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, \'super\', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = thing => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== \'undefined\' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n  const iterator = generator.call(obj);\n  let result;\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest(\'HTMLFormElement\');\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[_-\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n    return p1.toUpperCase() + p2;\n  });\n};\n\n/* Creating a function that will check if an object has a property. */\nconst utils_hasOwnProperty = (({\n  hasOwnProperty\n}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest(\'RegExp\');\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n  forEach(descriptors, (descriptor, name) => {\n    if (reducer(descriptor, name, obj) !== false) {\n      reducedDescriptors[name] = descriptor;\n    }\n  });\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = obj => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    const value = obj[name];\n    if (!isFunction(value)) return;\n    descriptor.enumerable = false;\n    if (\'writable\' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error(\'Can not read-only method \\\'\' + name + \'\\\'\');\n      };\n    }\n  });\n};\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n  const define = arr => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n  return obj;\n};\nconst noop = () => {};\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n};\n/* harmony default export */ const utils = ({\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, \'ECONNABORTED\').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.message = message;\n  this.name = \'AxiosError\';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nconst AxiosError_prototype = AxiosError.prototype;\nconst descriptors = {};\n[\'ERR_BAD_OPTION_VALUE\', \'ERR_BAD_OPTION\', \'ECONNABORTED\', \'ETIMEDOUT\', \'ERR_NETWORK\', \'ERR_FR_TOO_MANY_REDIRECTS\', \'ERR_DEPRECATED\', \'ERR_BAD_RESPONSE\', \'ERR_BAD_REQUEST\', \'ERR_CANCELED\', \'ERR_NOT_SUPPORT\', \'ERR_INVALID_URL\'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {\n    value: code\n  };\n});\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, \'isAxiosError\', {\n  value: true\n});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(AxiosError_prototype);\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== \'isAxiosError\';\n  });\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n  axiosError.cause = error;\n  axiosError.name = error.name;\n  customProps && Object.assign(axiosError, customProps);\n  return axiosError;\n};\n/* harmony default export */ const core_AxiosError = (AxiosError);\n// EXTERNAL MODULE: ./node_modules/form-data/lib/browser.js\nvar browser = __webpack_require__(612);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/env/classes/FormData.js\n\n/* harmony default export */ const classes_FormData = (browser);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js\n\n\n\n\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, \'[]\') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? \'[\' + token + \']\' : token;\n  }).join(dots ? \'.\' : \'\');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it\'s a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliant(thing) {\n  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === \'FormData\' && thing[Symbol.iterator];\n}\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'target must be an object\');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (classes_FormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== \'undefined\' && Blob;\n  const useBlob = _Blob && isSpecCompliant(formData);\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError(\'visitor must be a function\');\n  }\n  function convertValue(value) {\n    if (value === null) return \'\';\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError(\'Blob is not supported. Use a Buffer instead.\');\n    }\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === \'function\' ? new Blob([value]) : Buffer.from(value);\n    }\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n    if (value && !path && typeof value === \'object\') {\n      if (utils.endsWith(key, \'{}\')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (utils.isArray(value) && isFlatArray(value) || utils.isFileList(value) || utils.endsWith(key, \'[]\') && (arr = utils.toArray(value))) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n          // eslint-disable-next-line no-nested-ternary\n          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + \'[]\', convertValue(el));\n        });\n        return false;\n      }\n    }\n    if (isVisitable(value)) {\n      return true;\n    }\n    formData.append(renderKey(path, key, dots), convertValue(value));\n    return false;\n  }\n  const stack = [];\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n    if (stack.indexOf(value) !== -1) {\n      throw Error(\'Circular reference detected in \' + path.join(\'.\'));\n    }\n    stack.push(value);\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n    stack.pop();\n  }\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'data must be an object\');\n  }\n  build(obj);\n  return formData;\n}\n/* harmony default export */ const helpers_toFormData = (toFormData);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    \'!\': \'%21\',\n    "\'": \'%27\',\n    \'(\': \'%28\',\n    \')\': \'%29\',\n    \'~\': \'%7E\',\n    \'%20\': \'+\',\n    \'%00\': \'\\x00\'\n  };\n  return encodeURIComponent(str).replace(/[!\'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n  params && helpers_toFormData(params, this, options);\n}\nconst AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  const _encode = encoder ? function (value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + \'=\' + _encode(pair[1]);\n  }, \'\').join(\'&\');\n};\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, \':\').replace(/%24/g, \'$\').replace(/%2C/gi, \',\').replace(/%20/g, \'+\').replace(/%5B/gi, \'[\').replace(/%5D/gi, \']\');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  const _encode = options && options.encode || buildURL_encode;\n  const serializeFn = options && options.serialize;\n  let serializedParams;\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf("#");\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf(\'?\') === -1 ? \'?\' : \'&\') + serializedParams;\n  }\n  return url;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== \'undefined\' ? URLSearchParams : helpers_AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js\n\n\n/* harmony default export */ const browser_classes_FormData = (FormData);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js\n\n\n\n/**\n * Determine if we\'re running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> \'ReactNative\'\n * nativescript\n *  navigator.product -> \'NativeScript\' or \'NS\'\n *\n * @returns {boolean}\n */\nconst isStandardBrowserEnv = (() => {\n  let product;\n  if (typeof navigator !== \'undefined\' && ((product = navigator.product) === \'ReactNative\' || product === \'NativeScript\' || product === \'NS\')) {\n    return false;\n  }\n  return typeof window !== \'undefined\' && typeof document !== \'undefined\';\n})();\n/* harmony default export */ const platform_browser = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: browser_classes_FormData,\n    Blob\n  },\n  isStandardBrowserEnv,\n  protocols: [\'http\', \'https\', \'file\', \'blob\', \'url\', \'data\']\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/index.js\n\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new platform_browser.classes.URLSearchParams(), Object.assign({\n    visitor: function (value, key, path, helpers) {\n      if (platform_browser.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString(\'base64\'));\n        return false;\n      }\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `[\'foo\', \'x\', \'y\', \'z\']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === \'[]\' ? \'\' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n      return !isNumericKey;\n    }\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n    const result = buildPath(path, value, target[name], index);\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n    return !isNumericKey;\n  }\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n    return obj;\n  }\n  return null;\n}\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError(\'Request failed with status code \' + response.status, [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js\n\n\n\n\n/* harmony default export */ const cookies = (platform_browser.isStandardBrowserEnv ?\n// Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      const cookie = [];\n      cookie.push(name + \'=\' + encodeURIComponent(value));\n      if (utils.isNumber(expires)) {\n        cookie.push(\'expires=\' + new Date(expires).toGMTString());\n      }\n      if (utils.isString(path)) {\n        cookie.push(\'path=\' + path);\n      }\n      if (utils.isString(domain)) {\n        cookie.push(\'domain=\' + domain);\n      }\n      if (secure === true) {\n        cookie.push(\'secure\');\n      }\n      document.cookie = cookie.join(\'; \');\n    },\n    read: function read(name) {\n      const match = document.cookie.match(new RegExp(\'(^|;\\\\s*)(\' + name + \')=([^;]*)\'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, \'\', Date.now() - 86400000);\n    }\n  };\n}() :\n// Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}());\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, \'\') + \'/\' + relativeURL.replace(/^\\/+/, \'\') : baseURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n\n\n/* harmony default export */ const isURLSameOrigin = (platform_browser.isStandardBrowserEnv ?\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  const msie = /(msie|trident)/i.test(navigator.userAgent);\n  const urlParsingNode = document.createElement(\'a\');\n  let originURL;\n\n  /**\n  * Parse a URL to discover it\'s components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n  function resolveURL(url) {\n    let href = url;\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute(\'href\', href);\n      href = urlParsingNode.href;\n    }\n    urlParsingNode.setAttribute(\'href\', href);\n\n    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, \'\') : \'\',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, \'\') : \'\',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \'\') : \'\',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === \'/\' ? urlParsingNode.pathname : \'/\' + urlParsingNode.pathname\n    };\n  }\n  originURL = resolveURL(window.location.href);\n\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n  return function isURLSameOrigin(requestURL) {\n    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() :\n// Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}());\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? \'canceled\' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = \'CanceledError\';\n}\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || \'\';\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\'age\', \'authorization\', \'content-length\', \'content-type\', \'etag\', \'expires\', \'from\', \'host\', \'if-modified-since\', \'if-unmodified-since\', \'last-modified\', \'location\', \'max-forwards\', \'proxy-authorization\', \'referer\', \'retry-after\', \'user-agent\']);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n  rawHeaders && rawHeaders.split(\'\\n\').forEach(function parser(line) {\n    i = line.indexOf(\':\');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n    if (!key || parsed[key] && ignoreDuplicateOf[key]) {\n      return;\n    }\n    if (key === \'set-cookie\') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + \', \' + val : val;\n    }\n  });\n  return parsed;\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\n\n\nconst $internals = Symbol(\'internals\');\nconst $defaults = Symbol(\'defaults\');\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n  while (match = tokensRE.exec(str)) {\n    tokens[match[1]] = match[2];\n  }\n  return tokens;\n}\nfunction matchHeaderValue(context, value, header, filter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n  if (!utils.isString(value)) return;\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\nfunction formatHeader(header) {\n  return header.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n    return char.toUpperCase() + str;\n  });\n}\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(\' \' + header);\n  [\'get\', \'set\', \'has\'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function (arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\nfunction AxiosHeaders(headers, defaults) {\n  headers && this.set(headers);\n  this[$defaults] = defaults || null;\n}\nObject.assign(AxiosHeaders.prototype, {\n  set: function (header, valueOrRewrite, rewrite) {\n    const self = this;\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n      if (!lHeader) {\n        throw new Error(\'header name must be a non-empty string\');\n      }\n      const key = findKey(self, lHeader);\n      if (key && _rewrite !== true && (self[key] === false || _rewrite === false)) {\n        return;\n      }\n      self[key || _header] = normalizeValue(_value);\n    }\n    if (utils.isPlainObject(header)) {\n      utils.forEach(header, (_value, _header) => {\n        setHeader(_value, _header, valueOrRewrite);\n      });\n    } else {\n      setHeader(valueOrRewrite, header, rewrite);\n    }\n    return this;\n  },\n  get: function (header, parser) {\n    header = normalizeHeader(header);\n    if (!header) return undefined;\n    const key = findKey(this, header);\n    if (key) {\n      const value = this[key];\n      if (!parser) {\n        return value;\n      }\n      if (parser === true) {\n        return parseTokens(value);\n      }\n      if (utils.isFunction(parser)) {\n        return parser.call(this, value, key);\n      }\n      if (utils.isRegExp(parser)) {\n        return parser.exec(value);\n      }\n      throw new TypeError(\'parser must be boolean|regexp|function\');\n    }\n  },\n  has: function (header, matcher) {\n    header = normalizeHeader(header);\n    if (header) {\n      const key = findKey(this, header);\n      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n    return false;\n  },\n  delete: function (header, matcher) {\n    const self = this;\n    let deleted = false;\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n      if (_header) {\n        const key = findKey(self, _header);\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n          deleted = true;\n        }\n      }\n    }\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n    return deleted;\n  },\n  clear: function () {\n    return Object.keys(this).forEach(this.delete.bind(this));\n  },\n  normalize: function (format) {\n    const self = this;\n    const headers = {};\n    utils.forEach(this, (value, header) => {\n      const key = findKey(headers, header);\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n      const normalized = format ? formatHeader(header) : String(header).trim();\n      if (normalized !== header) {\n        delete self[header];\n      }\n      self[normalized] = normalizeValue(value);\n      headers[normalized] = true;\n    });\n    return this;\n  },\n  toJSON: function (asStrings) {\n    const obj = Object.create(null);\n    utils.forEach(Object.assign({}, this[$defaults] || null, this), (value, header) => {\n      if (value == null || value === false) return;\n      obj[header] = asStrings && utils.isArray(value) ? value.join(\', \') : value;\n    });\n    return obj;\n  }\n});\nObject.assign(AxiosHeaders, {\n  from: function (thing) {\n    if (utils.isString(thing)) {\n      return new this(parseHeaders(thing));\n    }\n    return thing instanceof this ? thing : new this(thing);\n  },\n  accessor: function (header) {\n    const internals = this[$internals] = this[$internals] = {\n      accessors: {}\n    };\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n    return this;\n  }\n});\nAxiosHeaders.accessor([\'Content-Type\', \'Content-Length\', \'Accept\', \'Accept-Encoding\', \'User-Agent\']);\nutils.freezeMethods(AxiosHeaders.prototype);\nutils.freezeMethods(AxiosHeaders);\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n  min = min !== undefined ? min : 1000;\n  return function push(chunkLength) {\n    const now = Date.now();\n    const startedAt = timestamps[tail];\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n    let i = tail;\n    let bytesCount = 0;\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n    head = (head + 1) % samplesCount;\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n    if (now - firstSampleTS < min) {\n      return;\n    }\n    const passed = startedAt && now - startedAt;\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n/* harmony default export */ const helpers_speedometer = (speedometer);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = helpers_speedometer(50, 250);\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n    bytesNotified = loaded;\n    const data = {\n      loaded,\n      total,\n      progress: total ? loaded / total : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined\n    };\n    data[isDownloadStream ? \'download\' : \'upload\'] = true;\n    listener(data);\n  };\n}\nfunction xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();\n    const responseType = config.responseType;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n      if (config.signal) {\n        config.signal.removeEventListener(\'abort\', onCanceled);\n      }\n    }\n    if (utils.isFormData(requestData) && platform_browser.isStandardBrowserEnv) {\n      requestHeaders.setContentType(false); // Let the browser set it\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || \'\';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : \'\';\n      requestHeaders.set(\'Authorization\', \'Basic \' + btoa(username + \':\' + password));\n    }\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = core_AxiosHeaders.from(\'getAllResponseHeaders\' in request && request.getAllResponseHeaders());\n      const responseData = !responseType || responseType === \'text\' || responseType === \'json\' ? request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n    if (\'onloadend\' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn\'t get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it\'s a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf(\'file:\') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next \'tick\'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n      reject(new core_AxiosError(\'Request aborted\', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it\'s a network error\n      reject(new core_AxiosError(\'Network Error\', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? \'timeout of \' + config.timeout + \'ms exceeded\' : \'timeout exceeded\';\n      const transitional = config.transitional || defaults_transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we\'re in a web worker, or react-native.\n    if (platform_browser.isStandardBrowserEnv) {\n      // Add xsrf header\n      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n      if (xsrfValue) {\n        requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if (\'setRequestHeader\' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== \'json\') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === \'function\') {\n      request.addEventListener(\'progress\', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === \'function\' && request.upload) {\n      request.upload.addEventListener(\'progress\', progressEventReducer(config.onUploadProgress));\n    }\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener(\'abort\', onCanceled);\n      }\n    }\n    const protocol = parseProtocol(fullPath);\n    if (protocol && platform_browser.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError(\'Unsupported protocol \' + protocol + \':\', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/index.js\n\n\n\nconst adapters = {\n  http: xhrAdapter,\n  xhr: xhrAdapter\n};\n/* harmony default export */ const lib_adapters = ({\n  getAdapter: nameOrAdapter => {\n    if (utils.isString(nameOrAdapter)) {\n      const adapter = adapters[nameOrAdapter];\n      if (!nameOrAdapter) {\n        throw Error(utils.hasOwnProp(nameOrAdapter) ? `Adapter \'${nameOrAdapter}\' is not available in the build` : `Can not resolve adapter \'${nameOrAdapter}\'`);\n      }\n      return adapter;\n    }\n    if (!utils.isFunction(nameOrAdapter)) {\n      throw new TypeError(\'adapter is not a function\');\n    }\n    return nameOrAdapter;\n  },\n  adapters\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_CONTENT_TYPE = {\n  \'Content-Type\': \'application/x-www-form-urlencoded\'\n};\n\n/**\n * If the browser has an XMLHttpRequest object, use the XHR adapter, otherwise use the HTTP\n * adapter\n *\n * @returns {Function}\n */\nfunction getDefaultAdapter() {\n  let adapter;\n  if (typeof XMLHttpRequest !== \'undefined\') {\n    // For browsers use XHR adapter\n    adapter = lib_adapters.getAdapter(\'xhr\');\n  } else if (typeof process !== \'undefined\' && utils.kindOf(process) === \'process\') {\n    // For node use HTTP adapter\n    adapter = lib_adapters.getAdapter(\'http\');\n  }\n  return adapter;\n}\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== \'SyntaxError\') {\n        throw e;\n      }\n    }\n  }\n  return (encoder || JSON.stringify)(rawValue);\n}\nconst defaults = {\n  transitional: defaults_transitional,\n  adapter: getDefaultAdapter(),\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || \'\';\n    const hasJSONContentType = contentType.indexOf(\'application/json\') > -1;\n    const isObjectPayload = utils.isObject(data);\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n    const isFormData = utils.isFormData(data);\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType(\'application/x-www-form-urlencoded;charset=utf-8\', false);\n      return data.toString();\n    }\n    let isFileList;\n    if (isObjectPayload) {\n      if (contentType.indexOf(\'application/x-www-form-urlencoded\') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf(\'multipart/form-data\') > -1) {\n        const _FormData = this.env && this.env.FormData;\n        return helpers_toFormData(isFileList ? {\n          \'files[]\': data\n        } : data, _FormData && new _FormData(), this.formSerializer);\n      }\n    }\n    if (isObjectPayload || hasJSONContentType) {\n      headers.setContentType(\'application/json\', false);\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === \'json\';\n    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === \'SyntaxError\') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n    return data;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: \'XSRF-TOKEN\',\n  xsrfHeaderName: \'X-XSRF-TOKEN\',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: platform_browser.classes.FormData,\n    Blob: platform_browser.classes.Blob\n  },\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n  headers: {\n    common: {\n      \'Accept\': \'application/json, text/plain, */*\'\n    }\n  }\n};\nutils.forEach([\'delete\', \'get\', \'head\'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach([\'post\', \'put\', \'patch\'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n/* harmony default export */ const lib_defaults = (defaults);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || lib_defaults;\n  const context = response || config;\n  const headers = core_AxiosHeaders.from(context.headers);\n  let data = context.data;\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n  headers.normalize();\n  return data;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(config, config.transformRequest);\n  const adapter = config.adapter || lib_defaults.adapter;\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(config, config.transformResponse, response);\n    response.headers = core_AxiosHeaders.from(response.headers);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(config, config.transformResponse, reason.response);\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n    return Promise.reject(reason);\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n  const mergeMap = {\n    \'url\': valueFromConfig2,\n    \'method\': valueFromConfig2,\n    \'data\': valueFromConfig2,\n    \'baseURL\': defaultToConfig2,\n    \'transformRequest\': defaultToConfig2,\n    \'transformResponse\': defaultToConfig2,\n    \'paramsSerializer\': defaultToConfig2,\n    \'timeout\': defaultToConfig2,\n    \'timeoutMessage\': defaultToConfig2,\n    \'withCredentials\': defaultToConfig2,\n    \'adapter\': defaultToConfig2,\n    \'responseType\': defaultToConfig2,\n    \'xsrfCookieName\': defaultToConfig2,\n    \'xsrfHeaderName\': defaultToConfig2,\n    \'onUploadProgress\': defaultToConfig2,\n    \'onDownloadProgress\': defaultToConfig2,\n    \'decompress\': defaultToConfig2,\n    \'maxContentLength\': defaultToConfig2,\n    \'maxBodyLength\': defaultToConfig2,\n    \'beforeRedirect\': defaultToConfig2,\n    \'transport\': defaultToConfig2,\n    \'httpAgent\': defaultToConfig2,\n    \'httpsAgent\': defaultToConfig2,\n    \'cancelToken\': defaultToConfig2,\n    \'socketPath\': defaultToConfig2,\n    \'responseEncoding\': defaultToConfig2,\n    \'validateStatus\': mergeDirectKeys\n  };\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(prop);\n    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n  });\n  return config;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js\nconst VERSION = "1.1.3";\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n[\'object\', \'boolean\', \'number\', \'function\', \'string\', \'symbol\'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || \'a\' + (i < 1 ? \'n \' : \' \') + type;\n  };\n});\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return \'[Axios v\' + VERSION + \'] Transitional option \\\'\' + opt + \'\\\'\' + desc + (message ? \'. \' + message : \'\');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new core_AxiosError(formatMessage(opt, \' has been removed\' + (version ? \' in \' + version : \'\')), core_AxiosError.ERR_DEPRECATED);\n    }\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(formatMessage(opt, \' has been deprecated since v\' + version + \' and will be removed in the near future\'));\n    }\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object\'s properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== \'object\') {\n    throw new core_AxiosError(\'options must be an object\', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError(\'option \' + opt + \' must be \' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError(\'Unknown option \' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n/* harmony default export */ const validator = ({\n  assertOptions,\n  validators\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js\n\n\n\n\n\n\n\n\n\n\nconst Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios(\'example/url\'[, config]) a la fetch API\n    if (typeof configOrUrl === \'string\') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n    config = mergeConfig(this.defaults, config);\n    const {\n      transitional,\n      paramsSerializer\n    } = config;\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)\n      }, false);\n    }\n    if (paramsSerializer !== undefined) {\n      validator.assertOptions(paramsSerializer, {\n        encode: Axios_validators.function,\n        serialize: Axios_validators.function\n      }, true);\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || \'get\').toLowerCase();\n\n    // Flatten headers\n    const defaultHeaders = config.headers && utils.merge(config.headers.common, config.headers[config.method]);\n    defaultHeaders && utils.forEach([\'delete\', \'get\', \'head\', \'post\', \'put\', \'patch\', \'common\'], function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    });\n    config.headers = new core_AxiosHeaders(config.headers, defaultHeaders);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === \'function\' && interceptor.runWhen(config) === false) {\n        return;\n      }\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n    let promise;\n    let i = 0;\n    let len;\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n      promise = Promise.resolve(config);\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n      return promise;\n    }\n    len = requestInterceptorChain.length;\n    let newConfig = config;\n    i = 0;\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    i = 0;\n    len = responseInterceptorChain.length;\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n    return promise;\n  }\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach([\'delete\', \'get\', \'head\', \'options\'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach([\'post\', \'put\', \'patch\'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          \'Content-Type\': \'multipart/form-data\'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n  Axios.prototype[method] = generateHTTPMethod();\n  Axios.prototype[method + \'Form\'] = generateHTTPMethod(true);\n});\n/* harmony default export */ const core_Axios = (Axios);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== \'function\') {\n      throw new TypeError(\'executor must be a function.\');\n    }\n    let resolvePromise;\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n      let i = token._listeners.length;\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n      return promise;\n    };\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && payload.isAxiosError === true;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new core_Axios(defaultConfig);\n  const instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {\n    allOwnKeys: true\n  });\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {\n    allOwnKeys: true\n  });\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios_axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios_axios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios_axios.CanceledError = cancel_CanceledError;\naxios_axios.CancelToken = cancel_CancelToken;\naxios_axios.isCancel = isCancel;\naxios_axios.VERSION = VERSION;\naxios_axios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios_axios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios_axios.Cancel = axios_axios.CanceledError;\n\n// Expose all/spread\naxios_axios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios_axios.spread = spread;\n\n// Expose isAxiosError\naxios_axios.isAxiosError = isAxiosError;\naxios_axios.formToJSON = thing => {\n  return helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n};\n/* harmony default export */ const lib_axios = (axios_axios);\n;// CONCATENATED MODULE: ./node_modules/axios/index.js\n\n\n// Keep top-level export same with static properties\n// so that it can keep same with es module or cjs\nconst {\n  Axios: axios_Axios,\n  AxiosError: axios_AxiosError,\n  CanceledError: axios_CanceledError,\n  isCancel: axios_isCancel,\n  CancelToken: axios_CancelToken,\n  VERSION: axios_VERSION,\n  all: axios_all,\n  Cancel,\n  isAxiosError: axios_isAxiosError,\n  spread: axios_spread,\n  toFormData: axios_toFormData\n} = lib_axios;\n/* harmony default export */ const node_modules_axios = (lib_axios);\n\n;// CONCATENATED MODULE: ./src/config.js\nvar config_apiUrl = document.location.href.startsWith(\'http://localhost\') ? \'http://localhost:5003\' : \'\';\n;// CONCATENATED MODULE: ./localStorage.js\nvar setUserInfo = function setUserInfo(_ref) {\n  var _ref$_id = _ref._id,\n    _id = _ref$_id === void 0 ? \'\' : _ref$_id,\n    _ref$name = _ref.name,\n    name = _ref$name === void 0 ? \'\' : _ref$name,\n    _ref$email = _ref.email,\n    email = _ref$email === void 0 ? \'\' : _ref$email,\n    _ref$password = _ref.password,\n    password = _ref$password === void 0 ? \'\' : _ref$password,\n    _ref$token = _ref.token,\n    token = _ref$token === void 0 ? \'\' : _ref$token,\n    _ref$isAdmin = _ref.isAdmin,\n    isAdmin = _ref$isAdmin === void 0 ? false : _ref$isAdmin;\n  localStorage.setItem(\'userInfo\', JSON.stringify({\n    _id: _id,\n    name: name,\n    email: email,\n    password: password,\n    token: token,\n    isAdmin: isAdmin\n  }));\n};\nvar clearUser = function clearUser() {\n  localStorage.removeItem(\'userInfo\');\n};\nvar localStorage_getUserInfo = function getUserInfo() {\n  return localStorage.getItem(\'userInfo\') ? JSON.parse(localStorage.getItem(\'userInfo\')) : {\n    name: \'\',\n    email: \'\',\n    password: \'\'\n  };\n};\n;// CONCATENATED MODULE: ./src/api.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar getProducts = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var _ref$searchKeyword, searchKeyword, queryString, response;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref$searchKeyword = _ref.searchKeyword, searchKeyword = _ref$searchKeyword === void 0 ? \'\' : _ref$searchKeyword;\n            _context.prev = 1;\n            queryString = \'?\';\n            if (searchKeyword) queryString += "searchKeyword=".concat(searchKeyword, "&");\n            _context.next = 6;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/products").concat(queryString),\n              method: \'GET\',\n              headers: {\n                \'Content-Type\': \'application/json\'\n              }\n            });\n          case 6:\n            response = _context.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context.next = 9;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 9:\n            return _context.abrupt("return", response.data);\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context["catch"](1);\n            console.log(_context.t0);\n            return _context.abrupt("return", {\n              error: _context.t0.response.data.message || _context.t0.message\n            });\n          case 16:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 12]]);\n  }));\n  return function getProducts(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar getProduct = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/products/").concat(id),\n              method: \'GET\',\n              headers: {\n                \'Content-Type\': \'application/json\'\n              }\n            });\n          case 3:\n            response = _context2.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context2.next = 6;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 6:\n            return _context2.abrupt("return", response.data);\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2["catch"](0);\n            console.log(_context2.t0);\n            return _context2.abrupt("return", {\n              error: _context2.t0.response.data.message || _context2.t0.message\n            });\n          case 13:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 9]]);\n  }));\n  return function getProduct(_x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar createProduct = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var _getUserInfo, token, response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _getUserInfo = localStorage_getUserInfo(), token = _getUserInfo.token;\n            _context3.next = 4;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/products"),\n              method: \'POST\',\n              headers: {\n                \'Content-Type\': \'application/json\',\n                Authorization: "Bearer ".concat(token)\n              }\n            });\n          case 4:\n            response = _context3.sent;\n            if (!(response.statusText !== \'Created\')) {\n              _context3.next = 7;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 7:\n            return _context3.abrupt("return", response.data);\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3["catch"](0);\n            return _context3.abrupt("return", {\n              error: _context3.t0.response.data.message || _context3.t0.message\n            });\n          case 13:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 10]]);\n  }));\n  return function createProduct() {\n    return _ref4.apply(this, arguments);\n  };\n}();\nvar deleteProduct = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(productId) {\n    var _getUserInfo2, token, response;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _getUserInfo2 = localStorage_getUserInfo(), token = _getUserInfo2.token;\n            _context4.next = 4;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/products/").concat(productId),\n              method: \'DELETE\',\n              headers: {\n                \'Content-Type\': \'application/json\',\n                Authorization: "Bearer ".concat(token)\n              }\n            });\n          case 4:\n            response = _context4.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context4.next = 7;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 7:\n            return _context4.abrupt("return", response.data);\n          case 10:\n            _context4.prev = 10;\n            _context4.t0 = _context4["catch"](0);\n            return _context4.abrupt("return", {\n              error: _context4.t0.response.data.message || _context4.t0.message\n            });\n          case 13:\n          case "end":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 10]]);\n  }));\n  return function deleteProduct(_x3) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nvar updateProduct = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(product) {\n    var _getUserInfo3, token, response;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _getUserInfo3 = localStorage_getUserInfo(), token = _getUserInfo3.token;\n            _context5.next = 4;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/products/").concat(product._id),\n              method: \'PUT\',\n              headers: {\n                \'Content-Type\': \'application/json\',\n                Authorization: "Bearer ".concat(token)\n              },\n              data: product\n            });\n          case 4:\n            response = _context5.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context5.next = 7;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 7:\n            return _context5.abrupt("return", response.data);\n          case 10:\n            _context5.prev = 10;\n            _context5.t0 = _context5["catch"](0);\n            return _context5.abrupt("return", {\n              error: _context5.t0.response.data.message || _context5.t0.message\n            });\n          case 13:\n          case "end":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 10]]);\n  }));\n  return function updateProduct(_x4) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nvar uploadProductImage = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(formData) {\n    var _getUserInfo4, token, response;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _getUserInfo4 = localStorage_getUserInfo(), token = _getUserInfo4.token;\n            _context6.next = 4;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/uploads"),\n              method: \'POST\',\n              headers: {\n                Authorization: "Bearer ".concat(token),\n                \'Content-Type\': \'multipart/form-data\'\n              },\n              data: formData\n            });\n          case 4:\n            response = _context6.sent;\n            if (!(response.statusText !== \'Created\')) {\n              _context6.next = 9;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 9:\n            return _context6.abrupt("return", response.data);\n          case 10:\n            _context6.next = 15;\n            break;\n          case 12:\n            _context6.prev = 12;\n            _context6.t0 = _context6["catch"](0);\n            return _context6.abrupt("return", {\n              error: _context6.t0.response.data.message || _context6.t0.message\n            });\n          case 15:\n          case "end":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 12]]);\n  }));\n  return function uploadProductImage(_x5) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nvar signin = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref8) {\n    var email, password, response;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            email = _ref8.email, password = _ref8.password;\n            _context7.prev = 1;\n            _context7.next = 4;\n            return node_modules_axios({\n              url: "".concat(config_apiUrl, "/api/users/signin"),\n              method: \'POST\',\n              header: {\n                \'Content-Type\': \'application/json\'\n              },\n              data: {\n                email: email,\n                password: password\n              }\n            });\n          case 4:\n            response = _context7.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context7.next = 7;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 7:\n            return _context7.abrupt("return", response.data);\n          case 10:\n            _context7.prev = 10;\n            _context7.t0 = _context7["catch"](1);\n            console.log(_context7.t0);\n            return _context7.abrupt("return", {\n              error: _context7.t0.response.data.message || _context7.t0.message\n            });\n          case 14:\n          case "end":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[1, 10]]);\n  }));\n  return function signin(_x6) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nvar update = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref10) {\n    var name, email, password, _getUserInfo5, _id, token, response;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            name = _ref10.name, email = _ref10.email, password = _ref10.password;\n            _context8.prev = 1;\n            _getUserInfo5 = getUserInfo(), _id = _getUserInfo5._id, token = _getUserInfo5.token;\n            _context8.next = 5;\n            return axios({\n              url: "".concat(apiUrl, "/api/users/").concat(_id),\n              method: \'PUT\',\n              headers: {\n                \'Content-Type\': \'application/json\',\n                Authorization: "Bearer ".concat(token)\n              },\n              data: {\n                name: name,\n                email: email,\n                password: password\n              }\n            });\n          case 5:\n            response = _context8.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context8.next = 8;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 8:\n            return _context8.abrupt("return", response.data);\n          case 11:\n            _context8.prev = 11;\n            _context8.t0 = _context8["catch"](1);\n            console.log(_context8.t0);\n            return _context8.abrupt("return", {\n              error: _context8.t0.response.data.message || _context8.t0.message\n            });\n          case 15:\n          case "end":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[1, 11]]);\n  }));\n  return function update(_x7) {\n    return _ref11.apply(this, arguments);\n  };\n}()));\nvar getSummary = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n    var _getUserInfo6, token, response;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            _getUserInfo6 = getUserInfo(), token = _getUserInfo6.token;\n            _context9.next = 4;\n            return axios({\n              url: "".concat(apiUrl, "/api/orders/summary"),\n              headers: {\n                Authorization: "Bearer ".concat(token),\n                \'content-type\': \'application/json\'\n              }\n            });\n          case 4:\n            response = _context9.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context9.next = 9;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 9:\n            return _context9.abrupt("return", response.data);\n          case 10:\n            _context9.next = 15;\n            break;\n          case 12:\n            _context9.prev = 12;\n            _context9.t0 = _context9["catch"](0);\n            return _context9.abrupt("return", {\n              error: _context9.t0.response ? _context9.t0.response.data.message : _context9.t0.message\n            });\n          case 15:\n          case "end":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[0, 12]]);\n  }));\n  return function getSummary() {\n    return _ref12.apply(this, arguments);\n  };\n}()));\nvar s3Upload = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(formData) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.prev = 0;\n            _context10.next = 3;\n            return axios({\n              url: "".concat(apiUrl, "/s3upload/upload"),\n              method: \'POST\',\n              headers: {\n                \'Content-Type\': \'multipart/form-data\'\n              },\n              data: formData\n            });\n          case 3:\n            response = _context10.sent;\n            if (!(response.statusText !== \'OK\')) {\n              _context10.next = 6;\n              break;\n            }\n            throw new Error(response.data.message);\n          case 6:\n            return _context10.abrupt("return", response.data);\n          case 9:\n            _context10.prev = 9;\n            _context10.t0 = _context10["catch"](0);\n            console.log(_context10.t0);\n            return _context10.abrupt("return", {\n              error: _context10.t0.response.data.message || _context10.t0.message\n            });\n          case 13:\n          case "end":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[0, 9]]);\n  }));\n  return function s3Upload(_x8) {\n    return _ref13.apply(this, arguments);\n  };\n}()));\n;// CONCATENATED MODULE: ./src/utils.js\nfunction utils_typeof(obj) { "@babel/helpers - typeof"; return utils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, utils_typeof(obj); }\nfunction utils_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ utils_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == utils_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction utils_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction utils_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { utils_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { utils_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nvar parseRequestUrl = function parseRequestUrl() {\n  var address = document.location.hash.slice(1).split(\'?\')[0];\n  var queryString = document.location.hash.slice(1).split(\'?\').length === 2 ? document.location.hash.slice(1).split(\'?\')[1] : \'\';\n  var url = address.toLowerCase() || \'/\';\n  var r = url.split(\'/\');\n  var q = queryString.split(\'=\');\n  return {\n    resource: r[1],\n    id: r[2],\n    verb: r[3],\n    name: q[0],\n    value: q[1]\n  };\n};\nvar rerender = /*#__PURE__*/function () {\n  var _ref = utils_asyncToGenerator( /*#__PURE__*/utils_regeneratorRuntime().mark(function _callee(component) {\n    return utils_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return component.render();\n          case 2:\n            document.getElementById(\'main-container\').innerHTML = _context.sent;\n            _context.next = 5;\n            return component.after_render();\n          case 5:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function rerender(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar showLoading = function showLoading() {\n  document.getElementById(\'loading-overlay\').classList.add(\'active\');\n};\nvar hideLoading = function hideLoading() {\n  document.getElementById(\'loading-overlay\').classList.remove(\'active\');\n};\nvar showMessage = function showMessage(message, callback) {\n  document.getElementById(\'message-overlay\').innerHTML = "\\n  <div>\\n    <div id=\\"message-overlay-content\\">".concat(message, "</div>\\n    <button id=\\"message-overlay-close-button\\">OK</button>\\n  </div>\\n  ");\n  document.getElementById(\'message-overlay\').classList.add(\'active\');\n  document.getElementById(\'message-overlay-close-button\').addEventListener(\'click\', function () {\n    document.getElementById(\'message-overlay\').classList.remove(\'active\');\n    if (callback) {\n      callback();\n    }\n  });\n};\nvar redirectUser = function redirectUser() {\n  document.location.hash = \'/\';\n};\n;// CONCATENATED MODULE: ./src/screens/HomeScreen.js\nfunction HomeScreen_typeof(obj) { "@babel/helpers - typeof"; return HomeScreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, HomeScreen_typeof(obj); }\nfunction HomeScreen_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ HomeScreen_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == HomeScreen_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction HomeScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction HomeScreen_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { HomeScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { HomeScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar HomeScreen = {\n  render: function () {\n    var _render = HomeScreen_asyncToGenerator( /*#__PURE__*/HomeScreen_regeneratorRuntime().mark(function _callee() {\n      var _parseRequestUrl, value, products;\n      return HomeScreen_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _parseRequestUrl = parseRequestUrl(), value = _parseRequestUrl.value;\n              _context.next = 3;\n              return getProducts({\n                searchKeyword: value\n              });\n            case 3:\n              products = _context.sent;\n              if (!products.error) {\n                _context.next = 6;\n                break;\n              }\n              return _context.abrupt("return", "<div class=\\"error\\">".concat(products.error, "</div>"));\n            case 6:\n              return _context.abrupt("return", "\\n        <ul class=\\"products\\">\\n         ".concat(products.map(function (product) {\n                return "\\n         <li>\\n            <div class=\\"product\\">\\n                <a href=\\"/#/product/".concat(product._id, "\\">\\n                    <img src=\\"").concat(product.image, "\\" alt=\\"").concat(product.name, "\\" />\\n                </a>\\n                <div class=\\"product-name\\">\\n                    <a href=\\"/#/product/").concat(product._id, "\\">\\n                        ").concat(product.name, "\\n                    </a>\\n                </div>\\n            </div>\\n         </li>\\n         ");\n              }).join(\'\\n\'), "\\n        "));\n            case 7:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function render() {\n      return _render.apply(this, arguments);\n    }\n    return render;\n  }()\n};\n/* harmony default export */ const screens_HomeScreen = (HomeScreen);\n;// CONCATENATED MODULE: ./src/screens/ProductScreen.js\nfunction ProductScreen_typeof(obj) { "@babel/helpers - typeof"; return ProductScreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ProductScreen_typeof(obj); }\nfunction ProductScreen_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ ProductScreen_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == ProductScreen_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ProductScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction ProductScreen_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { ProductScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { ProductScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar ProductScreen = {\n  after_render: function after_render() {},\n  render: function () {\n    var _render = ProductScreen_asyncToGenerator( /*#__PURE__*/ProductScreen_regeneratorRuntime().mark(function _callee() {\n      var request, product;\n      return ProductScreen_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              request = parseRequestUrl();\n              showLoading();\n              _context.next = 4;\n              return getProduct(request.id);\n            case 4:\n              product = _context.sent;\n              if (!product.error) {\n                _context.next = 7;\n                break;\n              }\n              return _context.abrupt("return", "<div>".concat(product.error, "</div>"));\n            case 7:\n              hideLoading();\n              return _context.abrupt("return", "\\n    <div class=\\"content\\">\\n      <div class=\\"back-to-result\\">\\n        <a href=\\"/#/\\">Back to result </a>\\n      </div>\\n      <div class=\\"details\\">\\n        <div class=\\"details-image\\">\\n          <img src=\\"".concat(product.image, "\\" alt=\\"").concat(product.name, "\\" />\\n        </div>\\n        <div class=\\"details-info\\">\\n          <ul>\\n            <li>\\n              <h1>").concat(product.name, "</h1>\\n            </li>\\n          </ul>\\n        </div>\\n      </div>\\n    </div>"));\n            case 9:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function render() {\n      return _render.apply(this, arguments);\n    }\n    return render;\n  }()\n};\n/* harmony default export */ const screens_ProductScreen = (ProductScreen);\n;// CONCATENATED MODULE: ./src/screens/ProductEditScreen.js\nfunction ProductEditScreen_typeof(obj) { "@babel/helpers - typeof"; return ProductEditScreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ProductEditScreen_typeof(obj); }\nfunction ProductEditScreen_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ ProductEditScreen_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == ProductEditScreen_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ProductEditScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction ProductEditScreen_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { ProductEditScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { ProductEditScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n// import FileSys from \'fs\';\n\n\n\nvar ProductEditScreen_FormData = __webpack_require__(612);\n// const http = require(\'http\');       \n// const FileSys = require(\'fs\');\n\nvar ProductEditScreen = {\n  after_render: function after_render() {\n    var request = parseRequestUrl();\n    document.getElementById(\'edit-product-form\').addEventListener(\'submit\', /*#__PURE__*/function () {\n      var _ref = ProductEditScreen_asyncToGenerator( /*#__PURE__*/ProductEditScreen_regeneratorRuntime().mark(function _callee(e) {\n        var data;\n        return ProductEditScreen_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                e.preventDefault();\n                showLoading();\n                _context.next = 4;\n                return updateProduct({\n                  _id: request.id,\n                  name: document.getElementById(\'name\').value,\n                  image: document.getElementById(\'image\').value,\n                  category: document.getElementById(\'category\').value\n                });\n              case 4:\n                data = _context.sent;\n                hideLoading();\n                if (data.error) {\n                  showMessage(data.error);\n                } else {\n                  document.location.hash = \'/productlist\';\n                }\n              case 7:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    document.getElementById(\'image-file\').addEventListener(\'change\', /*#__PURE__*/function () {\n      var _ref2 = ProductEditScreen_asyncToGenerator( /*#__PURE__*/ProductEditScreen_regeneratorRuntime().mark(function _callee2(e) {\n        var file, formData, data;\n        return ProductEditScreen_regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                file = e.target.files[0];\n                formData = new ProductEditScreen_FormData();\n                formData.append(\'image\', file);\n                showLoading();\n                _context2.next = 6;\n                return uploadProductImage(formData);\n              case 6:\n                data = _context2.sent;\n                hideLoading();\n                if (data.error) {\n                  showMessage(data.error);\n                } else {\n                  showMessage(\'Image uploaded successfully.\');\n                  document.getElementById(\'image\').value = data.image;\n                }\n              case 9:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  },\n  render: function () {\n    var _render = ProductEditScreen_asyncToGenerator( /*#__PURE__*/ProductEditScreen_regeneratorRuntime().mark(function _callee3() {\n      var request, product;\n      return ProductEditScreen_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              request = parseRequestUrl();\n              _context3.next = 3;\n              return getProduct(request.id);\n            case 3:\n              product = _context3.sent;\n              return _context3.abrupt("return", "\\n    <div class=\\"content\\">\\n      <div>\\n        <a href=\\"/#/productlist\\">Back to products</a>\\n      </div>\\n      <div class=\\"form-container\\">\\n        <form id=\\"edit-product-form\\" enctype=\\"multipart/form-data\\">\\n          <ul class=\\"form-items\\">\\n            <li>\\n              <h1>Edit Product ".concat(product._id.substring(0, 8), "</h1>\\n            </li>\\n            <li>\\n              <label for=\\"name\\">Name</label>\\n              <input type=\\"text\\" name=\\"name\\" value=\\"").concat(product.name, "\\" id=\\"name\\" />\\n            </li>\\n            <li>\\n              <label for=\\"image\\">Image (680 x 830)</label>\\n              <input type=\\"text\\" name=\\"image\\" value=\\"").concat(product.image, "\\" id=\\"image\\" />\\n              <input type=\\"file\\" name=\\"image-file\\" id=\\"image-file\\" accept=\\"image/*\\"/>\\n            </li>\\n            <li>\\n              <label for=\\"category\\">Category</label>\\n              <input type=\\"text\\" name=\\"category\\" value=\\"").concat(product.category, "\\" id=\\"category\\" />\\n            </li>\\n            \\n            <li>\\n              <button type=\\"submit\\" class=\\"primary\\">Update</button>\\n            </li>\\n          </ul>\\n        </form>\\n      </div>\\n\\n    </div>\\n    "));\n            case 5:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    function render() {\n      return _render.apply(this, arguments);\n    }\n    return render;\n  }()\n};\n/* harmony default export */ const screens_ProductEditScreen = (ProductEditScreen);\n;// CONCATENATED MODULE: ./src/components/DashboardMenu.js\nvar DashboardMenu = {\n  render: function render(props) {\n    return "\\n    <div class=\\"dashboard-menu\\">\\n      <ul>\\n        <li class=\\"".concat(props.selected === \'products\' ? \'selected\' : \'\', "\\">\\n          <a href=\\"/#/productlist\\">Products</a>\\n        </li>\\n      </ul>\\n    </div>\\n    ");\n  }\n};\n/* harmony default export */ const components_DashboardMenu = (DashboardMenu);\n;// CONCATENATED MODULE: ./src/screens/ProductListScreen.js\nfunction ProductListScreen_typeof(obj) { "@babel/helpers - typeof"; return ProductListScreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ProductListScreen_typeof(obj); }\nfunction ProductListScreen_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ ProductListScreen_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == ProductListScreen_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ProductListScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction ProductListScreen_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { ProductListScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { ProductListScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar ProductListScreen = {\n  after_render: function after_render() {\n    document.getElementById(\'create-product-button\').addEventListener(\'click\', /*#__PURE__*/ProductListScreen_asyncToGenerator( /*#__PURE__*/ProductListScreen_regeneratorRuntime().mark(function _callee() {\n      var data;\n      return ProductListScreen_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return createProduct();\n            case 2:\n              data = _context.sent;\n              document.location.hash = "/product/".concat(data.product._id, "/edit");\n            case 4:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n    var editButtons = document.getElementsByClassName(\'edit-button\');\n    Array.from(editButtons).forEach(function (editButton) {\n      editButton.addEventListener(\'click\', function () {\n        document.location.hash = "/product/".concat(editButton.id, "/edit");\n      });\n    });\n    var deleteButtons = document.getElementsByClassName(\'delete-button\');\n    Array.from(deleteButtons).forEach(function (deleteButton) {\n      deleteButton.addEventListener(\'click\', /*#__PURE__*/ProductListScreen_asyncToGenerator( /*#__PURE__*/ProductListScreen_regeneratorRuntime().mark(function _callee2() {\n        var data;\n        return ProductListScreen_regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!confirm(\'Are you sure to delete this product?\')) {\n                  _context2.next = 7;\n                  break;\n                }\n                showLoading();\n                _context2.next = 4;\n                return deleteProduct(deleteButton.id);\n              case 4:\n                data = _context2.sent;\n                if (data.error) {\n                  showMessage(data.error);\n                } else {\n                  rerender(ProductListScreen);\n                }\n                hideLoading();\n              case 7:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      })));\n    });\n  },\n  render: function () {\n    var _render = ProductListScreen_asyncToGenerator( /*#__PURE__*/ProductListScreen_regeneratorRuntime().mark(function _callee3() {\n      var products;\n      return ProductListScreen_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return getProducts({\n                searchKeyword: \'\'\n              });\n            case 2:\n              products = _context3.sent;\n              return _context3.abrupt("return", "\\n    <div class=\\"dashboard\\">\\n    ".concat(components_DashboardMenu.render({\n                selected: \'products\'\n              }), "\\n    <div class=\\"dashboard-content\\">\\n      <h1>Products</h1>\\n      <button id=\\"create-product-button\\" class=\\"primary\\">\\n        Create Product\\n      </button>\\n      <div class=\\"product-list\\">\\n        <table>\\n          <thead>\\n            <tr>\\n              <th>ID</th>\\n              <th>NAME</th>\\n              <th>CATEGORY</th>\\n              <th class=\\"tr-action\\">ACTION</th>\\n            <tr>\\n          </thead>\\n          <tbody>\\n            ").concat(products.map(function (product) {\n                return "\\n            <tr>\\n              <td>".concat(product._id, "</td>\\n              <td>").concat(product.name, "</td>\\n              <td>").concat(product.category, "</td>\\n              <td>\\n              <button id=\\"").concat(product._id, "\\" class=\\"edit-button\\">Edit</button>\\n              <button id=\\"").concat(product._id, "\\" class=\\"delete-button\\">Delete</button>\\n              </td>\\n            </tr>\\n            ");\n              }).join(\'\\n\'), "\\n          </tbody>\\n        </table>\\n      </div>\\n    </div>\\n  </div>\\n    "));\n            case 4:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    function render() {\n      return _render.apply(this, arguments);\n    }\n    return render;\n  }()\n};\n/* harmony default export */ const screens_ProductListScreen = (ProductListScreen);\n;// CONCATENATED MODULE: ./src/screens/Error404Screen.js\nvar Error404Screen = {\n  render: function render() {\n    return \'<div>Page not Found</div>\';\n  }\n};\n/* harmony default export */ const screens_Error404Screen = (Error404Screen);\n;// CONCATENATED MODULE: ./src/screens/SigninScreen.js\nfunction SigninScreen_typeof(obj) { "@babel/helpers - typeof"; return SigninScreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SigninScreen_typeof(obj); }\nfunction SigninScreen_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ SigninScreen_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == SigninScreen_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction SigninScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction SigninScreen_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { SigninScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { SigninScreen_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar SigninScreen = {\n  after_render: function after_render() {\n    document.getElementById(\'signin-form\').addEventListener(\'submit\', /*#__PURE__*/function () {\n      var _ref = SigninScreen_asyncToGenerator( /*#__PURE__*/SigninScreen_regeneratorRuntime().mark(function _callee(e) {\n        var data;\n        return SigninScreen_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                e.preventDefault();\n                showLoading();\n                _context.next = 4;\n                return signin({\n                  email: document.getElementById(\'email\').value,\n                  password: document.getElementById(\'password\').value\n                });\n              case 4:\n                data = _context.sent;\n                hideLoading();\n                if (data.error) {\n                  showMessage(data.error);\n                } else {\n                  setUserInfo(data);\n                  redirectUser();\n                }\n              case 7:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  },\n  render: function render() {\n    if (localStorage_getUserInfo().name) {\n      redirectUser();\n    }\n    return "\\n    <div class=\\"form-container\\">\\n      <form id=\\"signin-form\\">\\n        <ul class=\\"form-items\\">\\n          <li>\\n            <h1>Sign-In</h1>\\n          </li>\\n          <li>\\n            <label for=\\"email\\">Email</label>\\n            <input type=\\"email\\" name=\\"email\\" id=\\"email\\" />\\n          </li>\\n          <li>\\n            <label for=\\"password\\">Password</label>\\n            <input type=\\"password\\" name=\\"password\\" id=\\"password\\" />\\n          </li>\\n          <li>\\n            <button type=\\"submit\\" class=\\"primary\\">Signin</button>\\n          </li>\\n          <li>\\n            <div>\\n              New User?\\n              <a href=\\"/#/register\\">Create your account </a>\\n            </div>\\n          </li>\\n        </ul>\\n      </form>\\n    </div>\\n    ";\n  }\n};\n/* harmony default export */ const screens_SigninScreen = (SigninScreen);\n;// CONCATENATED MODULE: ./src/components/Header.js\nfunction Header_typeof(obj) { "@babel/helpers - typeof"; return Header_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Header_typeof(obj); }\nfunction Header_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ Header_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == Header_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction Header_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction Header_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { Header_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { Header_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar Header = {\n  render: function render() {\n    var _getUserInfo = localStorage_getUserInfo(),\n      name = _getUserInfo.name,\n      isAdmin = _getUserInfo.isAdmin;\n    var _parseRequestUrl = parseRequestUrl(),\n      value = _parseRequestUrl.value;\n    return " \\n  <div class=\\"brand\\">\\n    <button id=\\"aside-open-button\\">\\n      &#9776;\\n    </button>\\n    <a href=\\"/#/\\">NiyaCollections</a>\\n  </div>\\n  <div class=\\"search\\">\\n  <form class=\\"search-form\\"  id=\\"search-form\\">\\n    <input type=\\"text\\" name=\\"q\\" id=\\"q\\" value=\\"".concat(value || \'\', "\\" /> \\n    <button type=\\"submit\\"><i class=\\"fa fa-search\\"></i></button>\\n  </form>        \\n  </div>\\n  <div>\\n  ").concat(name ? "<a href=\\"/#/profile\\">".concat(name, "</a>") : "<a href=\\"/#/signin\\">Sign-In</a>", "    \\n    ").concat(isAdmin ? "<a href=\\"/#/productlist\\">Manage</a>" : \'\', "\\n  </div>");\n  },\n  after_render: function after_render() {\n    document.getElementById(\'search-form\').addEventListener(\'submit\', /*#__PURE__*/function () {\n      var _ref = Header_asyncToGenerator( /*#__PURE__*/Header_regeneratorRuntime().mark(function _callee(e) {\n        var searchKeyword;\n        return Header_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                e.preventDefault();\n                searchKeyword = document.getElementById(\'q\').value;\n                document.location.hash = "/?q=".concat(searchKeyword);\n              case 3:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    document.getElementById(\'aside-open-button\').addEventListener(\'click\', /*#__PURE__*/Header_asyncToGenerator( /*#__PURE__*/Header_regeneratorRuntime().mark(function _callee2() {\n      return Header_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              document.getElementById(\'aside-container\').classList.add(\'open\');\n            case 1:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    })));\n  }\n};\n/* harmony default export */ const components_Header = (Header);\n;// CONCATENATED MODULE: ./src/components/Aside.js\nfunction Aside_typeof(obj) { "@babel/helpers - typeof"; return Aside_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Aside_typeof(obj); }\nfunction Aside_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ Aside_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == Aside_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction Aside_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction Aside_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { Aside_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { Aside_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nvar Aside = {\n  render: function () {\n    var _render = Aside_asyncToGenerator( /*#__PURE__*/Aside_regeneratorRuntime().mark(function _callee() {\n      return Aside_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt("return", "\\n   <div class=\\"aside-header\\">\\n    <div>SHOP BY CATEGORY</div>\\n    <button class=\\"aside-close-button\\" id=\\"aside-close-button\\">x</button>\\n  </div>\\n  <div class=\\"aside-body\\">\\n    <ul class=\\"categories\\">\\n      <li>\\n        <a href=\\"/#/?q=Necklace\\"\\n          >Necklace\\n          <span><i class=\\"fa fa-chevron-right\\"></i></span>\\n        </a>\\n      </li>\\n      <li>\\n        <a href=\\"/#/?q=Bangle\\"\\n          >Bangles\\n          <span><i class=\\"fa fa-chevron-right\\"></i></span>\\n        </a>\\n      </li> \\n      <li>\\n        <a href=\\"/#/?q=EarRing\\"\\n          >EarRings\\n          <span><i class=\\"fa fa-chevron-right\\"></i></span>\\n        </a>\\n      </li> \\n    </ul>\\n  </div>");\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function render() {\n      return _render.apply(this, arguments);\n    }\n    return render;\n  }(),\n  after_render: function () {\n    var _after_render = Aside_asyncToGenerator( /*#__PURE__*/Aside_regeneratorRuntime().mark(function _callee3() {\n      return Aside_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              document.getElementById(\'aside-container\').classList.remove(\'open\');\n              document.getElementById(\'aside-close-button\').addEventListener(\'click\', /*#__PURE__*/Aside_asyncToGenerator( /*#__PURE__*/Aside_regeneratorRuntime().mark(function _callee2() {\n                return Aside_regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        document.getElementById(\'aside-container\').classList.remove(\'open\');\n                      case 1:\n                      case "end":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              })));\n            case 2:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    function after_render() {\n      return _after_render.apply(this, arguments);\n    }\n    return after_render;\n  }()\n};\n/* harmony default export */ const components_Aside = (Aside);\n;// CONCATENATED MODULE: ./src/index.js\nfunction src_typeof(obj) { "@babel/helpers - typeof"; return src_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, src_typeof(obj); }\nfunction src_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ src_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == src_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction src_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n\n\n\nvar routes = {\n  \'/\': screens_HomeScreen,\n  \'/product/:id/edit\': screens_ProductEditScreen,\n  \'/product/:id\': screens_ProductScreen,\n  \'/signin\': screens_SigninScreen,\n  \'/productlist\': screens_ProductListScreen\n};\nvar router = /*#__PURE__*/function () {\n  var _ref = src_asyncToGenerator( /*#__PURE__*/src_regeneratorRuntime().mark(function _callee() {\n    var request, parseUrl, screen, header, aside, main;\n    return src_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            showLoading();\n            request = parseRequestUrl();\n            parseUrl = (request.resource ? "/".concat(request.resource) : \'/\') + (request.id ? \'/:id\' : \'\') + (request.verb ? "/".concat(request.verb) : \'\');\n            screen = routes[parseUrl] ? routes[parseUrl] : screens_Error404Screen;\n            header = document.getElementById(\'header-container\');\n            _context.next = 7;\n            return components_Header.render();\n          case 7:\n            header.innerHTML = _context.sent;\n            _context.next = 10;\n            return components_Header.after_render();\n          case 10:\n            aside = document.getElementById(\'aside-container\');\n            _context.next = 13;\n            return components_Aside.render();\n          case 13:\n            aside.innerHTML = _context.sent;\n            _context.next = 16;\n            return components_Aside.after_render();\n          case 16:\n            main = document.getElementById(\'main-container\');\n            _context.next = 19;\n            return screen.render();\n          case 19:\n            main.innerHTML = _context.sent;\n            if (!screen.after_render) {\n              _context.next = 23;\n              break;\n            }\n            _context.next = 23;\n            return screen.after_render();\n          case 23:\n            hideLoading();\n          case 24:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function router() {\n    return _ref.apply(this, arguments);\n  };\n}();\nwindow.addEventListener(\'load\', router);\nwindow.addEventListener(\'hashchange\', router);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQUEsS0FDVmtDLE1BQU0sQ0FBQ2pDLFlBQVk7Y0FBQTtjQUFBO1lBQUE7WUFBQTtZQUFBLE9BQVFpQyxNQUFNLENBQUNqQyxZQUFZLEVBQUU7VUFBQTtZQUNwREksV0FBVyxFQUFFO1VBQUM7VUFBQTtZQUFBO1FBQUE7TUFBQTtJQUFBO0VBQUEsQ0FDakI7RUFBQSxnQkFuQksyQixNQUFNO0lBQUE7RUFBQTtBQUFBLEdBbUJYO0FBQ0Q1WSxNQUFNLENBQUMrTSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU2TCxNQUFNLENBQUM7QUFDdkM1WSxNQUFNLENBQUMrTSxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU2TCxNQUFNLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzFkMmIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzP2M1MzIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcz83OTE3Iiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvY2xhc3Nlcy9Gb3JtRGF0YS5qcz80YjZiIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanM/ZTQ2NyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcz9iOTIyIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzPzMwYjUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2Y2YjQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcz9jYWZhIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzPzJhZjYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9Gb3JtRGF0YS5qcz84MzI0Iiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2luZGV4LmpzP2YzYmQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2luZGV4LmpzPzRlZDQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcz9lNDBjIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzPzA3ZjQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzPzQ2N2YiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz83YWFjIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanM/ZDkyNSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcz9lNjgzIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanM/ODNiOSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/MzkzNCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanM/ZmI2MCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzP2I2OGEiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2MzNDUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NIZWFkZXJzLmpzP2VkZDUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanM/NjdiZiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzP2I1MGQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2luZGV4LmpzPzVhYmQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzPzRjM2QiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz9jNDAxIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/MmU2NyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/NTI3MCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcz80YTdiIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcz81Y2NlIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcz84NDhiIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzPzBhMDYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz84ZGY0Iiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcz8wZGY2Iiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcz81ZjAyIiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcz9jZWU0Iiwid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzP2JjM2EiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9zcmMvY29uZmlnLmpzP2RiNDkiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9sb2NhbFN0b3JhZ2UuanM/NzlhOSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy9hcGkuanM/ZDcyMiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy91dGlscy5qcz8wMjVlIiwid2VicGFjazovL2Zyb250ZW5kLy4vc3JjL3NjcmVlbnMvSG9tZVNjcmVlbi5qcz83MDczIiwid2VicGFjazovL2Zyb250ZW5kLy4vc3JjL3NjcmVlbnMvUHJvZHVjdFNjcmVlbi5qcz9mYTYwIiwid2VicGFjazovL2Zyb250ZW5kLy4vc3JjL3NjcmVlbnMvUHJvZHVjdEVkaXRTY3JlZW4uanM/ZWU2YyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUuanM/MDM2ZiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy9zY3JlZW5zL1Byb2R1Y3RMaXN0U2NyZWVuLmpzPzY1YzUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9zcmMvc2NyZWVucy9FcnJvcjQwNFNjcmVlbi5qcz8wNDU1Iiwid2VicGFjazovL2Zyb250ZW5kLy4vc3JjL3NjcmVlbnMvU2lnbmluU2NyZWVuLmpzP2ZmZWMiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9zcmMvY29tcG9uZW50cy9IZWFkZXIuanM/YWQ4ZSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL0FzaWRlLmpzPzlmOWQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBjb25zdCBwYXR0ZXJuID0gJ1tvYmplY3QgRm9ybURhdGFdJztcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8XG4gICAgdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IHBhdHRlcm4gfHxcbiAgICAoaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gcGF0dGVybilcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIHthbGxPd25LZXlzID0gZmFsc2V9ID0ge30pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGw7XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGNvbnN0IGtleXMgPSBhbGxPd25LZXlzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXNzaWduVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhcmd1bWVudHNbaV0gJiYgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5c11cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuY29uc3QgZXh0ZW5kID0gKGEsIGIsIHRoaXNBcmcsIHthbGxPd25LZXlzfT0ge30pID0+IHtcbiAgZm9yRWFjaChiLCAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAodGhpc0FyZyAmJiBpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSwge2FsbE93bktleXN9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmNvbnN0IHN0cmlwQk9NID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVzY3JpcHRvcnNdXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGluaGVyaXRzID0gKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpID0+IHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZGVzY3JpcHRvcnMpO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnc3VwZXInLCB7XG4gICAgdmFsdWU6IHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlXG4gIH0pO1xuICBwcm9wcyAmJiBPYmplY3QuYXNzaWduKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW59IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCB0b0ZsYXRPYmplY3QgPSAoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIsIHByb3BGaWx0ZXIpID0+IHtcbiAgbGV0IHByb3BzO1xuICBsZXQgaTtcbiAgbGV0IHByb3A7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICgoIXByb3BGaWx0ZXIgfHwgcHJvcEZpbHRlcihwcm9wLCBzb3VyY2VPYmosIGRlc3RPYmopKSAmJiAhbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PiB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIG5ldyBhcnJheSBmcm9tIGFycmF5IGxpa2Ugb2JqZWN0IG9yIG51bGwgaWYgZmFpbGVkXG4gKlxuICogQHBhcmFtIHsqfSBbdGhpbmddXG4gKlxuICogQHJldHVybnMgez9BcnJheX1cbiAqL1xuY29uc3QgdG9BcnJheSA9ICh0aGluZykgPT4ge1xuICBpZiAoIXRoaW5nKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzQXJyYXkodGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGxldCBpID0gdGhpbmcubGVuZ3RoO1xuICBpZiAoIWlzTnVtYmVyKGkpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgYXJyID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGFycltpXSA9IHRoaW5nW2ldO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogQ2hlY2tpbmcgaWYgdGhlIFVpbnQ4QXJyYXkgZXhpc3RzIGFuZCBpZiBpdCBkb2VzLCBpdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gKiB0aGluZyBwYXNzZWQgaW4gaXMgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX1cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiB0aGluZyA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBGb3IgZWFjaCBlbnRyeSBpbiB0aGUgb2JqZWN0LCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBrZXkgYW5kIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVudHJ5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBvYmogJiYgb2JqW1N5bWJvbC5pdGVyYXRvcl07XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnRXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPn1cbiAqL1xuY29uc3QgbWF0Y2hBbGwgPSAocmVnRXhwLCBzdHIpID0+IHtcbiAgbGV0IG1hdGNoZXM7XG4gIGNvbnN0IGFyciA9IFtdO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXy1cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgaWYgKHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IGRlc2NyaXB0b3I7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHJlZHVjZWREZXNjcmlwdG9ycyk7XG59XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXJcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zRXJyb3IucHJvdG90eXBlO1xuY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcblxuW1xuICAnRVJSX0JBRF9PUFRJT05fVkFMVUUnLFxuICAnRVJSX0JBRF9PUFRJT04nLFxuICAnRUNPTk5BQk9SVEVEJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFUlJfTkVUV09SSycsXG4gICdFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTJyxcbiAgJ0VSUl9ERVBSRUNBVEVEJyxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxuICAnRVJSX0JBRF9SRVFVRVNUJyxcbiAgJ0VSUl9DQU5DRUxFRCcsXG4gICdFUlJfTk9UX1NVUFBPUlQnLFxuICAnRVJSX0lOVkFMSURfVVJMJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbl0uZm9yRWFjaChjb2RlID0+IHtcbiAgZGVzY3JpcHRvcnNbY29kZV0gPSB7dmFsdWU6IGNvZGV9O1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEF4aW9zRXJyb3IsIGRlc2NyaXB0b3JzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdpc0F4aW9zRXJyb3InLCB7dmFsdWU6IHRydWV9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbkF4aW9zRXJyb3IuZnJvbSA9IChlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpID0+IHtcbiAgY29uc3QgYXhpb3NFcnJvciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcblxuICB1dGlscy50b0ZsYXRPYmplY3QoZXJyb3IsIGF4aW9zRXJyb3IsIGZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBFcnJvci5wcm90b3R5cGU7XG4gIH0sIHByb3AgPT4ge1xuICAgIHJldHVybiBwcm9wICE9PSAnaXNBeGlvc0Vycm9yJztcbiAgfSk7XG5cbiAgQXhpb3NFcnJvci5jYWxsKGF4aW9zRXJyb3IsIGVycm9yLm1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gIGF4aW9zRXJyb3IuY2F1c2UgPSBlcnJvcjtcblxuICBheGlvc0Vycm9yLm5hbWUgPSBlcnJvci5uYW1lO1xuXG4gIGN1c3RvbVByb3BzICYmIE9iamVjdC5hc3NpZ24oYXhpb3NFcnJvciwgY3VzdG9tUHJvcHMpO1xuXG4gIHJldHVybiBheGlvc0Vycm9yO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NFcnJvcjtcbiIsImltcG9ydCBGb3JtRGF0YSBmcm9tICdmb3JtLWRhdGEnO1xuZXhwb3J0IGRlZmF1bHQgRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IGVudkZvcm1EYXRhIGZyb20gJy4uL2Vudi9jbGFzc2VzL0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB0aGluZyBpcyBhIGFycmF5IG9yIGpzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhpbmcgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIHZpc2l0ZWQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmlzaXRhYmxlKHRoaW5nKSB7XG4gIHJldHVybiB1dGlscy5pc1BsYWluT2JqZWN0KHRoaW5nKSB8fCB1dGlscy5pc0FycmF5KHRoaW5nKTtcbn1cblxuLyoqXG4gKiBJdCByZW1vdmVzIHRoZSBicmFja2V0cyBmcm9tIHRoZSBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgd2l0aG91dCB0aGUgYnJhY2tldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJyYWNrZXRzKGtleSkge1xuICByZXR1cm4gdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSA/IGtleS5zbGljZSgwLCAtMikgOiBrZXk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXRoLCBhIGtleSwgYW5kIGEgYm9vbGVhbiwgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjdXJyZW50IG9iamVjdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdHMgLSBJZiB0cnVlLCB0aGUga2V5IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBkb3RzIGluc3RlYWQgb2YgYnJhY2tldHMuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICovXG5mdW5jdGlvbiByZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSB7XG4gIGlmICghcGF0aCkgcmV0dXJuIGtleTtcbiAgcmV0dXJuIHBhdGguY29uY2F0KGtleSkubWFwKGZ1bmN0aW9uIGVhY2godG9rZW4sIGkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB0b2tlbiA9IHJlbW92ZUJyYWNrZXRzKHRva2VuKTtcbiAgICByZXR1cm4gIWRvdHMgJiYgaSA/ICdbJyArIHRva2VuICsgJ10nIDogdG9rZW47XG4gIH0pLmpvaW4oZG90cyA/ICcuJyA6ICcnKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgYXJyYXkgaXMgYW4gYXJyYXkgYW5kIG5vbmUgb2YgaXRzIGVsZW1lbnRzIGFyZSB2aXNpdGFibGUsIHRoZW4gaXQncyBhIGZsYXQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGbGF0QXJyYXkoYXJyKSB7XG4gIHJldHVybiB1dGlscy5pc0FycmF5KGFycikgJiYgIWFyci5zb21lKGlzVmlzaXRhYmxlKTtcbn1cblxuY29uc3QgcHJlZGljYXRlcyA9IHV0aWxzLnRvRmxhdE9iamVjdCh1dGlscywge30sIG51bGwsIGZ1bmN0aW9uIGZpbHRlcihwcm9wKSB7XG4gIHJldHVybiAvXmlzW0EtWl0vLnRlc3QocHJvcCk7XG59KTtcblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgJiYgdXRpbHMuaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YScgJiYgdGhpbmdbU3ltYm9sLml0ZXJhdG9yXTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cbiAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52aXNpdG9yXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXRhVG9rZW5zID0gdHJ1ZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG90cyA9IGZhbHNlXVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gW29wdGlvbnMuaW5kZXhlcyA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiovXG5cbi8qKlxuICogSXQgY29udmVydHMgYW4gb2JqZWN0IGludG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBmb3JtIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgLSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRvRm9ybURhdGEob2JqLCBmb3JtRGF0YSwgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyAoZW52Rm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgaXNTcGVjQ29tcGxpYW50KGZvcm1EYXRhKTtcblxuICBpZiAoIXV0aWxzLmlzRnVuY3Rpb24odmlzaXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aXNpdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscy5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSlcbiAgICAgICAgKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gcmVtb3ZlQnJhY2tldHMoa2V5KTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiBlYWNoKGVsLCBpbmRleCkge1xuICAgICAgICAgICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXG4gICAgICAgICAgICBjb252ZXJ0VmFsdWUoZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBjb25zdCBleHBvc2VkSGVscGVycyA9IE9iamVjdC5hc3NpZ24ocHJlZGljYXRlcywge1xuICAgIGRlZmF1bHRWaXNpdG9yLFxuICAgIGNvbnZlcnRWYWx1ZSxcbiAgICBpc1Zpc2l0YWJsZVxuICB9KTtcblxuICBmdW5jdGlvbiBidWlsZCh2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhdGguam9pbignLicpKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgIHV0aWxzLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIGVhY2goZWwsIGtleSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIHZpc2l0b3IuY2FsbChcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscy5pc1N0cmluZyhrZXkpID8ga2V5LnRyaW0oKSA6IGtleSwgcGF0aCwgZXhwb3NlZEhlbHBlcnNcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Gb3JtRGF0YTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSk7XG4gIH0gOiBlbmNvZGU7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcblxuLyoqXG4gKiBJdCByZXBsYWNlcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjaGFyYWN0ZXJzIGA6YCwgYCRgLCBgLGAsIGArYCwgYFtgLCBhbmQgYF1gIHdpdGggdGhlaXJcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xuXG4gIGxldCBzZXJpYWxpemVkUGFyYW1zO1xuXG4gIGlmIChzZXJpYWxpemVGbikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBzZXJpYWxpemVGbihwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgSW50ZXJjZXB0b3JNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAqL1xuICB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICBmdWxmaWxsZWQsXG4gICAgICByZWplY3RlZCxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoaWQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtRGF0YTtcbiIsImltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcydcbmltcG9ydCBGb3JtRGF0YSBmcm9tICcuL2NsYXNzZXMvRm9ybURhdGEuanMnXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1N0YW5kYXJkQnJvd3NlckVudiA9ICgoKSA9PiB7XG4gIGxldCBwcm9kdWN0O1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIChwcm9kdWN0ID0gbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgcHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICBwcm9kdWN0ID09PSAnTlMnKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXG59O1xuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vbm9kZS9pbmRleC5qcyc7XG5cbmV4cG9ydCB7cGxhdGZvcm0gYXMgZGVmYXVsdH1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvRm9ybURhdGEoZGF0YSwgbmV3IHBsYXRmb3JtLmNsYXNzZXMuVVJMU2VhcmNoUGFyYW1zKCksIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwgb3B0aW9ucykpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL0F4aW9zRXJyb3IuanMnO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgY29uc3QgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4vLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGlzQWJzb2x1dGVVUkwgZnJvbSAnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJztcbmltcG9ydCBjb21iaW5lVVJMcyBmcm9tICcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5pc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgY29uc3QgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGV0IG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICBsZXQgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzLnRvT2JqZWN0U2V0KFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5jb25zdCAkZGVmYXVsdHMgPSBTeW1ib2woJ2RlZmF1bHRzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVyVmFsdWUoY29udGV4dCwgdmFsdWUsIGhlYWRlciwgZmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIEF4aW9zSGVhZGVycyhoZWFkZXJzLCBkZWZhdWx0cykge1xuICBoZWFkZXJzICYmIHRoaXMuc2V0KGhlYWRlcnMpO1xuICB0aGlzWyRkZWZhdWx0c10gPSBkZWZhdWx0cyB8fCBudWxsO1xufVxuXG5PYmplY3QuYXNzaWduKEF4aW9zSGVhZGVycy5wcm90b3R5cGUsIHtcbiAgc2V0OiBmdW5jdGlvbihoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYgKGtleSAmJiBfcmV3cml0ZSAhPT0gdHJ1ZSAmJiAoc2VsZltrZXldID09PSBmYWxzZSB8fCBfcmV3cml0ZSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikpIHtcbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVyLCAoX3ZhbHVlLCBfaGVhZGVyKSA9PiB7XG4gICAgICAgIHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIHZhbHVlT3JSZXdyaXRlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbihoZWFkZXIsIHBhcnNlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKCFoZWFkZXIpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBrZXkgPSBmaW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRva2Vucyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmV4ZWModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgIH1cbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBkZWxldGU6IGZ1bmN0aW9uKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVIZWFkZXIoX2hlYWRlcikge1xuICAgICAgX2hlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKF9oZWFkZXIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZmluZEtleShzZWxmLCBfaGVhZGVyKTtcblxuICAgICAgICBpZiAoa2V5ICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHNlbGYsIHNlbGZba2V5XSwga2V5LCBtYXRjaGVyKSkpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuXG4gICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIuZm9yRWFjaChkZWxldGVIZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfSxcblxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2godGhpcy5kZWxldGUuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBmaW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2goT2JqZWN0LmFzc2lnbih7fSwgdGhpc1skZGVmYXVsdHNdIHx8IG51bGwsIHRoaXMpLFxuICAgICAgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIG9ialtoZWFkZXJdID0gYXNTdHJpbmdzICYmIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG59KTtcblxuT2JqZWN0LmFzc2lnbihBeGlvc0hlYWRlcnMsIHtcbiAgZnJvbTogZnVuY3Rpb24odGhpbmcpIHtcbiAgICBpZiAodXRpbHMuaXNTdHJpbmcodGhpbmcpKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMocGFyc2VIZWFkZXJzKHRoaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfSxcblxuICBhY2Nlc3NvcjogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQXhpb3NIZWFkZXJzLmFjY2Vzc29yKFsnQ29udGVudC1UeXBlJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0FjY2VwdCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnVXNlci1BZ2VudCddKTtcblxudXRpbHMuZnJlZXplTWV0aG9kcyhBeGlvc0hlYWRlcnMucHJvdG90eXBlKTtcbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuICBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgY29va2llcyBmcm9tICcuLy4uL2hlbHBlcnMvY29va2llcy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi8uLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBzcGVlZG9tZXRlciBmcm9tICcuLi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzJztcblxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFJlZHVjZXIobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0pIHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgZGF0YVtpc0Rvd25sb2FkU3RyZWFtID8gJ2Rvd25sb2FkJyA6ICd1cGxvYWQnXSA9IHRydWU7XG5cbiAgICBsaXN0ZW5lcihkYXRhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIGxldCBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSAmJiBwbGF0Zm9ybS5pc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUoZmFsc2UpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIGNvbnN0IHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmIChwbGF0Zm9ybS5pc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKVxuICAgICAgICAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgJiYgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSk7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KGNvbmZpZy54c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLnRvSlNPTigpLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25VcGxvYWRQcm9ncmVzcykpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4gfHwgY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBjYW5jZWwgPT4ge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgY2FuY2VsLnR5cGUgPyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcsIHJlcXVlc3QpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbiAmJiBjb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb3RvY29sID0gcGFyc2VQcm90b2NvbChmdWxsUGF0aCk7XG5cbiAgICBpZiAocHJvdG9jb2wgJiYgcGxhdGZvcm0ucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wgKyAnOicsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBjb25maWcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBodHRwQWRhcHRlciBmcm9tICcuL2h0dHAuanMnO1xuaW1wb3J0IHhockFkYXB0ZXIgZnJvbSAnLi94aHIuanMnO1xuXG5jb25zdCBhZGFwdGVycyA9IHtcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXG4gIHhocjogeGhyQWRhcHRlclxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldEFkYXB0ZXI6IChuYW1lT3JBZGFwdGVyKSA9PiB7XG4gICAgaWYodXRpbHMuaXNTdHJpbmcobmFtZU9yQWRhcHRlcikpe1xuICAgICAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzW25hbWVPckFkYXB0ZXJdO1xuXG4gICAgICBpZiAoIW5hbWVPckFkYXB0ZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgdXRpbHMuaGFzT3duUHJvcChuYW1lT3JBZGFwdGVyKSA/XG4gICAgICAgICAgICBgQWRhcHRlciAnJHtuYW1lT3JBZGFwdGVyfScgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGRgIDpcbiAgICAgICAgICAgIGBDYW4gbm90IHJlc29sdmUgYWRhcHRlciAnJHtuYW1lT3JBZGFwdGVyfSdgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGFwdGVyXG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKG5hbWVPckFkYXB0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhZGFwdGVyIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVPckFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4vdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4uL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgdG9VUkxFbmNvZGVkRm9ybSBmcm9tICcuLi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuLi9hZGFwdGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogSWYgdGhlIGJyb3dzZXIgaGFzIGFuIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCwgdXNlIHRoZSBYSFIgYWRhcHRlciwgb3RoZXJ3aXNlIHVzZSB0aGUgSFRUUFxuICogYWRhcHRlclxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIGxldCBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcigneGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHV0aWxzLmtpbmRPZihwcm9jZXNzKSA9PT0gJ3Byb2Nlc3MnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKCdodHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIGlmICghaGFzSlNPTkNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7P09iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmbnMsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb250ZXh0LmhlYWRlcnMpO1xuICBsZXQgZGF0YSA9IGNvbnRleHQuZGF0YTtcblxuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29uZmlnLCBkYXRhLCBoZWFkZXJzLm5vcm1hbGl6ZSgpLCByZXNwb25zZSA/IHJlc3BvbnNlLnN0YXR1cyA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuXG4gIGhlYWRlcnMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRyYW5zZm9ybURhdGEgZnJvbSAnLi90cmFuc2Zvcm1EYXRhLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpO1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgY29uc3QgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdtZXRob2QnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdkYXRhJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlcXVlc3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXNwb25zZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dE1lc3NhZ2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdhZGFwdGVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VUeXBlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmSGVhZGVyTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uVXBsb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdkZWNvbXByZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Q29udGVudExlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdiZWZvcmVSZWRpcmVjdCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zcG9ydCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBzQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdjYW5jZWxUb2tlbic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3NvY2tldFBhdGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZUVuY29kaW5nJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndmFsaWRhdGVTdGF0dXMnOiBtZXJnZURpcmVjdEtleXNcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuMS4zXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplcn0gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgJiYgdXRpbHMubWVyZ2UoXG4gICAgICBjb25maWcuaGVhZGVycy5jb21tb24sXG4gICAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBkZWZhdWx0SGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gbmV3IEF4aW9zSGVhZGVycyhjb25maWcuaGVhZGVycywgZGVmYXVsdEhlYWRlcnMpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgbGV0IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGxldCBwcm9taXNlO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuO1xuXG4gICAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICAgIGNvbnN0IGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdC5iaW5kKHRoaXMpLCB1bmRlZmluZWRdO1xuICAgICAgY2hhaW4udW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaC5hcHBseShjaGFpbiwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluW2krK10sIGNoYWluW2krK10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZW4gPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICBsZXQgbmV3Q29uZmlnID0gY29uZmlnO1xuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9DYW5jZWxlZEVycm9yLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsVG9rZW59XG4gKi9cbmNsYXNzIENhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcbiAgICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgICB9XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XG4gICAgICBsZXQgX3Jlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICAgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICAgKi9cbiAgc3RhdGljIHNvdXJjZSgpIHtcbiAgICBsZXQgY2FuY2VsO1xuICAgIGNvbnN0IHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICAgIGNhbmNlbCA9IGM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2FuY2VsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcbmltcG9ydCBBeGlvcyBmcm9tICcuL2NvcmUvQXhpb3MuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vY29yZS9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gJy4vY2FuY2VsL0NhbmNlbFRva2VuLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHNwcmVhZCBmcm9tICcuL2hlbHBlcnMvc3ByZWFkLmpzJztcbmltcG9ydCBpc0F4aW9zRXJyb3IgZnJvbSAnLi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgY29uc3QgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0LCBudWxsLCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbmNvbnN0IGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XG5heGlvcy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xuYXhpb3MuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmF4aW9zLlZFUlNJT04gPSBWRVJTSU9OO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvcjtcblxuLy8gYWxpYXMgZm9yIENhbmNlbGVkRXJyb3IgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbmF4aW9zLnNwcmVhZCA9IHNwcmVhZDtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gaXNBeGlvc0Vycm9yO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4ge1xuICByZXR1cm4gZm9ybURhdGFUb0pTT04odXRpbHMuaXNIVE1MRm9ybSh0aGluZykgPyBuZXcgRm9ybURhdGEodGhpbmcpIDogdGhpbmcpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsImltcG9ydCBheGlvcyBmcm9tICcuL2xpYi9heGlvcy5qcyc7XG5cbi8vIEtlZXAgdG9wLWxldmVsIGV4cG9ydCBzYW1lIHdpdGggc3RhdGljIHByb3BlcnRpZXNcbi8vIHNvIHRoYXQgaXQgY2FuIGtlZXAgc2FtZSB3aXRoIGVzIG1vZHVsZSBvciBjanNcbmNvbnN0IHtcbiAgQXhpb3MsXG4gIEF4aW9zRXJyb3IsXG4gIENhbmNlbGVkRXJyb3IsXG4gIGlzQ2FuY2VsLFxuICBDYW5jZWxUb2tlbixcbiAgVkVSU0lPTixcbiAgYWxsLFxuICBDYW5jZWwsXG4gIGlzQXhpb3NFcnJvcixcbiAgc3ByZWFkLFxuICB0b0Zvcm1EYXRhXG59ID0gYXhpb3M7XG5cbmV4cG9ydCBkZWZhdWx0IGF4aW9zO1xuZXhwb3J0IHtcbiAgQXhpb3MsXG4gIEF4aW9zRXJyb3IsXG4gIENhbmNlbGVkRXJyb3IsXG4gIGlzQ2FuY2VsLFxuICBDYW5jZWxUb2tlbixcbiAgVkVSU0lPTixcbiAgYWxsLFxuICBDYW5jZWwsXG4gIGlzQXhpb3NFcnJvcixcbiAgc3ByZWFkLFxuICB0b0Zvcm1EYXRhXG59XG4iLCJleHBvcnQgY29uc3QgYXBpVXJsID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZi5zdGFydHNXaXRoKCdodHRwOi8vbG9jYWxob3N0JylcclxuPyAnaHR0cDovL2xvY2FsaG9zdDo1MDAzJ1xyXG46ICcnOyIsIlxyXG5leHBvcnQgY29uc3Qgc2V0VXNlckluZm8gPSAoe1xyXG4gIF9pZCA9ICcnLFxyXG4gIG5hbWUgPSAnJyxcclxuICBlbWFpbCA9ICcnLFxyXG4gIHBhc3N3b3JkID0gJycsXHJcbiAgdG9rZW4gPSAnJyxcclxuICBpc0FkbWluID0gZmFsc2UsXHJcbn0pID0+IHtcclxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcclxuICAgICd1c2VySW5mbycsXHJcbiAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIF9pZCxcclxuICAgICAgbmFtZSxcclxuICAgICAgZW1haWwsXHJcbiAgICAgIHBhc3N3b3JkLFxyXG4gICAgICB0b2tlbixcclxuICAgICAgaXNBZG1pbixcclxuICAgIH0pXHJcbiAgKTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGNsZWFyVXNlciA9ICgpID0+IHtcclxuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlckluZm8nKTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGdldFVzZXJJbmZvID0gKCkgPT4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJJbmZvJylcclxuICAgID8gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlckluZm8nKSlcclxuICAgIDogeyBuYW1lOiAnJywgZW1haWw6ICcnLCBwYXNzd29yZDogJycgfTtcclxuXHJcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB7IGFwaVVybCB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgZ2V0VXNlckluZm8gfSBmcm9tICcuLi9sb2NhbFN0b3JhZ2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFByb2R1Y3RzID0gYXN5bmMgKHsgc2VhcmNoS2V5d29yZCA9ICcnIH0pID0+IHtcclxuICB0cnkge1xyXG4gICAgbGV0IHF1ZXJ5U3RyaW5nID0gJz8nO1xyXG4gICAgaWYgKHNlYXJjaEtleXdvcmQpIHF1ZXJ5U3RyaW5nICs9IGBzZWFyY2hLZXl3b3JkPSR7c2VhcmNoS2V5d29yZH0mYDtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKHtcclxuICAgICAgdXJsOiBgJHthcGlVcmx9L2FwaS9wcm9kdWN0cyR7cXVlcnlTdHJpbmd9YCxcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0ICE9PSAnT0snKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgcmV0dXJuIHsgZXJyb3I6IGVyci5yZXNwb25zZS5kYXRhLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UgfTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UHJvZHVjdCA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKHtcclxuICAgICAgdXJsOiBgJHthcGlVcmx9L2FwaS9wcm9kdWN0cy8ke2lkfWAsXHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzVGV4dCAhPT0gJ09LJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgIHJldHVybiB7IGVycm9yOiBlcnIucmVzcG9uc2UuZGF0YS5tZXNzYWdlIHx8IGVyci5tZXNzYWdlIH07XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9kdWN0ID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHRva2VuIH0gPSBnZXRVc2VySW5mbygpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgIHVybDogYCR7YXBpVXJsfS9hcGkvcHJvZHVjdHNgLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0ICE9PSAnQ3JlYXRlZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiB7IGVycm9yOiBlcnIucmVzcG9uc2UuZGF0YS5tZXNzYWdlIHx8IGVyci5tZXNzYWdlIH07XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcm9kdWN0ID0gYXN5bmMgKHByb2R1Y3RJZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHRva2VuIH0gPSBnZXRVc2VySW5mbygpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgIHVybDogYCR7YXBpVXJsfS9hcGkvcHJvZHVjdHMvJHtwcm9kdWN0SWR9YCxcclxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0ICE9PSAnT0snKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZSB8fCBlcnIubWVzc2FnZSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVQcm9kdWN0ID0gYXN5bmMgKHByb2R1Y3QpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0b2tlbiB9ID0gZ2V0VXNlckluZm8oKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3Moe1xyXG4gICAgICB1cmw6IGAke2FwaVVybH0vYXBpL3Byb2R1Y3RzLyR7cHJvZHVjdC5faWR9YCxcclxuICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGRhdGE6IHByb2R1Y3QsXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNUZXh0ICE9PSAnT0snKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZSB8fCBlcnIubWVzc2FnZSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGxvYWRQcm9kdWN0SW1hZ2UgPSBhc3luYyAoZm9ybURhdGEpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0b2tlbiB9ID0gZ2V0VXNlckluZm8oKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3Moe1xyXG4gICAgICB1cmw6IGAke2FwaVVybH0vYXBpL3VwbG9hZHNgLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXHJcbiAgICAgIH0sXHJcbiAgICAgIGRhdGE6IGZvcm1EYXRhLFxyXG4gICAgfSk7XHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzVGV4dCAhPT0gJ0NyZWF0ZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZSB8fCBlcnIubWVzc2FnZSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaWduaW4gPSBhc3luYyAoeyBlbWFpbCwgcGFzc3dvcmQgfSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKHtcclxuICAgICAgdXJsOiBgJHthcGlVcmx9L2FwaS91c2Vycy9zaWduaW5gLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIHBhc3N3b3JkLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzVGV4dCAhPT0gJ09LJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgIHJldHVybiB7IGVycm9yOiBlcnIucmVzcG9uc2UuZGF0YS5tZXNzYWdlIHx8IGVyci5tZXNzYWdlIH07XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZSA9IGFzeW5jICh7IG5hbWUsIGVtYWlsLCBwYXNzd29yZCB9KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgX2lkLCB0b2tlbiB9ID0gZ2V0VXNlckluZm8oKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3Moe1xyXG4gICAgICB1cmw6IGAke2FwaVVybH0vYXBpL3VzZXJzLyR7X2lkfWAsXHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c1RleHQgIT09ICdPSycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZSB8fCBlcnIubWVzc2FnZSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTdW1tYXJ5ID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHRva2VuIH0gPSBnZXRVc2VySW5mbygpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgIHVybDogYCR7YXBpVXJsfS9hcGkvb3JkZXJzL3N1bW1hcnlgLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c1RleHQgIT09ICdPSycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiB7IGVycm9yOiBlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2UuZGF0YS5tZXNzYWdlIDogZXJyLm1lc3NhZ2UgfTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgczNVcGxvYWQgPSBhc3luYyAoZm9ybURhdGEpID0+IHtcclxuICB0cnkge1xyXG5cclxuICAgLy8gYWxlcnQoYGZpbGUgbmFtZSA6ICR7ZmlsZS5uYW1lfWApO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgIHVybDogYCR7YXBpVXJsfS9zM3VwbG9hZC91cGxvYWRgLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogIHsnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnfSwgXHJcbiAgICAgIGRhdGE6IGZvcm1EYXRhLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c1RleHQgIT09ICdPSycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZSB8fCBlcnIubWVzc2FnZSB9O1xyXG4gIH1cclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IHBhcnNlUmVxdWVzdFVybCA9ICgpID0+IHtcclxuICBjb25zdCBhZGRyZXNzID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaC5zbGljZSgxKS5zcGxpdCgnPycpWzBdO1xyXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID1cclxuICAgIGRvY3VtZW50LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkuc3BsaXQoJz8nKS5sZW5ndGggPT09IDJcclxuICAgICAgPyBkb2N1bWVudC5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpLnNwbGl0KCc/JylbMV1cclxuICAgICAgOiAnJztcclxuXHJcbiAgY29uc3QgdXJsID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpIHx8ICcvJztcclxuICBjb25zdCByID0gdXJsLnNwbGl0KCcvJyk7XHJcbiAgY29uc3QgcSA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCc9Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc291cmNlOiByWzFdLFxyXG4gICAgaWQ6IHJbMl0sXHJcbiAgICB2ZXJiOiByWzNdLFxyXG4gICAgbmFtZTogcVswXSxcclxuICAgIHZhbHVlOiBxWzFdLFxyXG4gIH07XHJcbn07XHJcbmV4cG9ydCBjb25zdCByZXJlbmRlciA9IGFzeW5jIChjb21wb25lbnQpID0+IHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbi1jb250YWluZXInKS5pbm5lckhUTUwgPVxyXG4gICAgYXdhaXQgY29tcG9uZW50LnJlbmRlcigpO1xyXG4gIGF3YWl0IGNvbXBvbmVudC5hZnRlcl9yZW5kZXIoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaG93TG9hZGluZyA9ICgpID0+IHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZy1vdmVybGF5JykuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGlkZUxvYWRpbmcgPSAoKSA9PiB7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmctb3ZlcmxheScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG59O1xyXG5leHBvcnQgY29uc3Qgc2hvd01lc3NhZ2UgPSAobWVzc2FnZSwgY2FsbGJhY2spID0+IHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZS1vdmVybGF5JykuaW5uZXJIVE1MID0gYFxyXG4gIDxkaXY+XHJcbiAgICA8ZGl2IGlkPVwibWVzc2FnZS1vdmVybGF5LWNvbnRlbnRcIj4ke21lc3NhZ2V9PC9kaXY+XHJcbiAgICA8YnV0dG9uIGlkPVwibWVzc2FnZS1vdmVybGF5LWNsb3NlLWJ1dHRvblwiPk9LPC9idXR0b24+XHJcbiAgPC9kaXY+XHJcbiAgYDtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZS1vdmVybGF5JykuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgZG9jdW1lbnRcclxuICAgIC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZS1vdmVybGF5LWNsb3NlLWJ1dHRvbicpXHJcbiAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZXNzYWdlLW92ZXJsYXknKS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcbmV4cG9ydCBjb25zdCByZWRpcmVjdFVzZXIgPSAoKSA9PiB7XHJcbiAgICBkb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gJy8nO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBnZXRQcm9kdWN0cyB9IGZyb20gJy4uL2FwaSc7XHJcbmltcG9ydCB7IHBhcnNlUmVxdWVzdFVybCB9IGZyb20gJy4uL3V0aWxzJztcclxuXHJcbmNvbnN0IEhvbWVTY3JlZW4gPSB7XHJcbiAgICByZW5kZXI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBwYXJzZVJlcXVlc3RVcmwoKTtcclxuICAgIGNvbnN0IHByb2R1Y3RzID0gYXdhaXQgZ2V0UHJvZHVjdHMoeyBzZWFyY2hLZXl3b3JkOiB2YWx1ZSB9KTtcclxuICAgIGlmIChwcm9kdWN0cy5lcnJvcikge1xyXG4gICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJlcnJvclwiPiR7cHJvZHVjdHMuZXJyb3J9PC9kaXY+YDtcclxuICAgIH1cclxuXHJcbiAgICAgICByZXR1cm4gYFxyXG4gICAgICAgIDx1bCBjbGFzcz1cInByb2R1Y3RzXCI+XHJcbiAgICAgICAgICR7cHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiBgXHJcbiAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3RcIj5cclxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvIy9wcm9kdWN0LyR7cHJvZHVjdC5faWR9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke3Byb2R1Y3QuaW1hZ2V9XCIgYWx0PVwiJHtwcm9kdWN0Lm5hbWV9XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9kdWN0LW5hbWVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiLyMvcHJvZHVjdC8ke3Byb2R1Y3QuX2lkfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAke3Byb2R1Y3QubmFtZX1cclxuICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgIGApLmpvaW4oJ1xcbicpfVxyXG4gICAgICAgIGA7XHJcbiAgICB9LFxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBIb21lU2NyZWVuO1xyXG4iLCJpbXBvcnQge1xyXG4gIHBhcnNlUmVxdWVzdFVybCxcclxuICBzaG93TG9hZGluZyxcclxuICBoaWRlTG9hZGluZyxcclxuICBcclxufSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IGdldFByb2R1Y3QgfSBmcm9tICcuLi9hcGknO1xyXG5cclxuXHJcbmNvbnN0IFByb2R1Y3RTY3JlZW4gPSB7XHJcbiAgYWZ0ZXJfcmVuZGVyOiAoKSA9PiB7XHJcbiAgICBcclxuICB9LFxyXG4gIHJlbmRlcjogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHBhcnNlUmVxdWVzdFVybCgpO1xyXG4gICAgc2hvd0xvYWRpbmcoKTtcclxuICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBnZXRQcm9kdWN0KHJlcXVlc3QuaWQpO1xyXG4gICAgaWYgKHByb2R1Y3QuZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIGA8ZGl2PiR7cHJvZHVjdC5lcnJvcn08L2Rpdj5gO1xyXG4gICAgfVxyXG4gICAgaGlkZUxvYWRpbmcoKTtcclxuICAgIHJldHVybiBgXHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYmFjay10by1yZXN1bHRcIj5cclxuICAgICAgICA8YSBocmVmPVwiLyMvXCI+QmFjayB0byByZXN1bHQgPC9hPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImRldGFpbHNcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGV0YWlscy1pbWFnZVwiPlxyXG4gICAgICAgICAgPGltZyBzcmM9XCIke3Byb2R1Y3QuaW1hZ2V9XCIgYWx0PVwiJHtwcm9kdWN0Lm5hbWV9XCIgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGV0YWlscy1pbmZvXCI+XHJcbiAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8aDE+JHtwcm9kdWN0Lm5hbWV9PC9oMT5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+YDtcclxuICB9LFxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBQcm9kdWN0U2NyZWVuO1xyXG4iLCIvLyBpbXBvcnQgRmlsZVN5cyBmcm9tICdmcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIHBhcnNlUmVxdWVzdFVybCxcclxuICBzaG93TG9hZGluZyxcclxuICBzaG93TWVzc2FnZSxcclxuICBoaWRlTG9hZGluZyxcclxufSBmcm9tICcuLi91dGlscyc7XHJcblxyXG5pbXBvcnQgeyBnZXRQcm9kdWN0LCB1cGRhdGVQcm9kdWN0LCB1cGxvYWRQcm9kdWN0SW1hZ2UgfSBmcm9tICcuLi9hcGknO1xyXG5cclxuY29uc3QgRm9ybURhdGEgPSByZXF1aXJlKCdmb3JtLWRhdGEnKTtcclxuLy8gY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTsgICAgICAgXHJcbi8vIGNvbnN0IEZpbGVTeXMgPSByZXF1aXJlKCdmcycpO1xyXG5cclxuXHJcbmNvbnN0IFByb2R1Y3RFZGl0U2NyZWVuID0ge1xyXG4gIGFmdGVyX3JlbmRlcjogKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IHJlcXVlc3QgPSBwYXJzZVJlcXVlc3RVcmwoKTtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZCgnZWRpdC1wcm9kdWN0LWZvcm0nKVxyXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgYXN5bmMgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdXBkYXRlUHJvZHVjdCh7XHJcbiAgICAgICAgICBfaWQ6IHJlcXVlc3QuaWQsXHJcbiAgICAgICAgICBuYW1lOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmFtZScpLnZhbHVlLFxyXG4gICAgICAgICAgaW1hZ2U6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWFnZScpLnZhbHVlLFxyXG4gICAgICAgICAgY2F0ZWdvcnk6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRlZ29yeScpLnZhbHVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgIHNob3dNZXNzYWdlKGRhdGEuZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gJy9wcm9kdWN0bGlzdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZCgnaW1hZ2UtZmlsZScpXHJcbiAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBhc3luYyAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcclxuICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ltYWdlJywgZmlsZSk7XHJcbiAgICAgICAgc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdXBsb2FkUHJvZHVjdEltYWdlKGZvcm1EYXRhKTtcclxuICAgICAgICBoaWRlTG9hZGluZygpO1xyXG4gICAgICAgIGlmIChkYXRhLmVycm9yKSB7XHJcbiAgICAgICAgICBzaG93TWVzc2FnZShkYXRhLmVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2hvd01lc3NhZ2UoJ0ltYWdlIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseS4nKTtcclxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWFnZScpLnZhbHVlID0gZGF0YS5pbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICBcclxuICB9LFxyXG4gIHJlbmRlcjogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHBhcnNlUmVxdWVzdFVybCgpO1xyXG4gICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IGdldFByb2R1Y3QocmVxdWVzdC5pZCk7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgICAgPGRpdj5cclxuICAgICAgICA8YSBocmVmPVwiLyMvcHJvZHVjdGxpc3RcIj5CYWNrIHRvIHByb2R1Y3RzPC9hPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGZvcm0gaWQ9XCJlZGl0LXByb2R1Y3QtZm9ybVwiIGVuY3R5cGU9XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCI+XHJcbiAgICAgICAgICA8dWwgY2xhc3M9XCJmb3JtLWl0ZW1zXCI+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8aDE+RWRpdCBQcm9kdWN0ICR7cHJvZHVjdC5faWQuc3Vic3RyaW5nKDAsIDgpfTwvaDE+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibmFtZVwiPk5hbWU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJuYW1lXCIgdmFsdWU9XCIke1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdC5uYW1lXHJcbiAgICAgICAgICAgICAgfVwiIGlkPVwibmFtZVwiIC8+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiaW1hZ2VcIj5JbWFnZSAoNjgwIHggODMwKTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImltYWdlXCIgdmFsdWU9XCIke1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdC5pbWFnZVxyXG4gICAgICAgICAgICAgIH1cIiBpZD1cImltYWdlXCIgLz5cclxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwiaW1hZ2UtZmlsZVwiIGlkPVwiaW1hZ2UtZmlsZVwiIGFjY2VwdD1cImltYWdlLypcIi8+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY2F0ZWdvcnlcIj5DYXRlZ29yeTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImNhdGVnb3J5XCIgdmFsdWU9XCIke1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdC5jYXRlZ29yeVxyXG4gICAgICAgICAgICAgIH1cIiBpZD1cImNhdGVnb3J5XCIgLz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cInByaW1hcnlcIj5VcGRhdGU8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfSxcclxuXHJcbiAgXHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IFByb2R1Y3RFZGl0U2NyZWVuO1xyXG4iLCJjb25zdCBEYXNoYm9hcmRNZW51ID0ge1xyXG4gIHJlbmRlcjogKHByb3BzKSA9PiBgXHJcbiAgICA8ZGl2IGNsYXNzPVwiZGFzaGJvYXJkLW1lbnVcIj5cclxuICAgICAgPHVsPlxyXG4gICAgICAgIDxsaSBjbGFzcz1cIiR7cHJvcHMuc2VsZWN0ZWQgPT09ICdwcm9kdWN0cycgPyAnc2VsZWN0ZWQnIDogJyd9XCI+XHJcbiAgICAgICAgICA8YSBocmVmPVwiLyMvcHJvZHVjdGxpc3RcIj5Qcm9kdWN0czwvYT5cclxuICAgICAgICA8L2xpPlxyXG4gICAgICA8L3VsPlxyXG4gICAgPC9kaXY+XHJcbiAgICBgLFxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBEYXNoYm9hcmRNZW51O1xyXG4iLCJpbXBvcnQgRGFzaGJvYXJkTWVudSBmcm9tICcuLi9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUnO1xyXG5pbXBvcnQgeyBnZXRQcm9kdWN0cywgY3JlYXRlUHJvZHVjdCwgZGVsZXRlUHJvZHVjdCB9IGZyb20gJy4uL2FwaSc7XHJcbmltcG9ydCB7IHNob3dMb2FkaW5nLCBoaWRlTG9hZGluZywgcmVyZW5kZXIsIHNob3dNZXNzYWdlIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuY29uc3QgUHJvZHVjdExpc3RTY3JlZW4gPSB7XHJcbiAgYWZ0ZXJfcmVuZGVyOiAoKSA9PiB7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAuZ2V0RWxlbWVudEJ5SWQoJ2NyZWF0ZS1wcm9kdWN0LWJ1dHRvbicpXHJcbiAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY3JlYXRlUHJvZHVjdCgpO1xyXG4gICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSBgL3Byb2R1Y3QvJHtkYXRhLnByb2R1Y3QuX2lkfS9lZGl0YDtcclxuICAgICAgfSk7XHJcbiAgICBjb25zdCBlZGl0QnV0dG9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2VkaXQtYnV0dG9uJyk7XHJcbiAgICBBcnJheS5mcm9tKGVkaXRCdXR0b25zKS5mb3JFYWNoKChlZGl0QnV0dG9uKSA9PiB7XHJcbiAgICAgIGVkaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGAvcHJvZHVjdC8ke2VkaXRCdXR0b24uaWR9L2VkaXRgO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZGVsZXRlQnV0dG9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RlbGV0ZS1idXR0b24nKTtcclxuICAgIEFycmF5LmZyb20oZGVsZXRlQnV0dG9ucykuZm9yRWFjaCgoZGVsZXRlQnV0dG9uKSA9PiB7XHJcbiAgICAgIGRlbGV0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzLCBuby1hbGVydFxyXG4gICAgICAgIGlmIChjb25maXJtKCdBcmUgeW91IHN1cmUgdG8gZGVsZXRlIHRoaXMgcHJvZHVjdD8nKSkge1xyXG4gICAgICAgICAgc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkZWxldGVQcm9kdWN0KGRlbGV0ZUJ1dHRvbi5pZCk7XHJcbiAgICAgICAgICBpZiAoZGF0YS5lcnJvcikge1xyXG4gICAgICAgICAgICBzaG93TWVzc2FnZShkYXRhLmVycm9yKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcmVuZGVyKFByb2R1Y3RMaXN0U2NyZWVuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgcmVuZGVyOiBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBwcm9kdWN0cyA9IGF3YWl0IGdldFByb2R1Y3RzKHsgc2VhcmNoS2V5d29yZDogJycgfSk7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgPGRpdiBjbGFzcz1cImRhc2hib2FyZFwiPlxyXG4gICAgJHtEYXNoYm9hcmRNZW51LnJlbmRlcih7IHNlbGVjdGVkOiAncHJvZHVjdHMnIH0pfVxyXG4gICAgPGRpdiBjbGFzcz1cImRhc2hib2FyZC1jb250ZW50XCI+XHJcbiAgICAgIDxoMT5Qcm9kdWN0czwvaDE+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJjcmVhdGUtcHJvZHVjdC1idXR0b25cIiBjbGFzcz1cInByaW1hcnlcIj5cclxuICAgICAgICBDcmVhdGUgUHJvZHVjdFxyXG4gICAgICA8L2J1dHRvbj5cclxuICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtbGlzdFwiPlxyXG4gICAgICAgIDx0YWJsZT5cclxuICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgIDx0aD5JRDwvdGg+XHJcbiAgICAgICAgICAgICAgPHRoPk5BTUU8L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5DQVRFR09SWTwvdGg+XHJcbiAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidHItYWN0aW9uXCI+QUNUSU9OPC90aD5cclxuICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgJHtwcm9kdWN0c1xyXG4gICAgICAgICAgICAgIC5tYXAoXHJcbiAgICAgICAgICAgICAgICAocHJvZHVjdCkgPT4gYFxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgPHRkPiR7cHJvZHVjdC5faWR9PC90ZD5cclxuICAgICAgICAgICAgICA8dGQ+JHtwcm9kdWN0Lm5hbWV9PC90ZD5cclxuICAgICAgICAgICAgICA8dGQ+JHtwcm9kdWN0LmNhdGVnb3J5fTwvdGQ+XHJcbiAgICAgICAgICAgICAgPHRkPlxyXG4gICAgICAgICAgICAgIDxidXR0b24gaWQ9XCIke3Byb2R1Y3QuX2lkfVwiIGNsYXNzPVwiZWRpdC1idXR0b25cIj5FZGl0PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cIiR7cHJvZHVjdC5faWR9XCIgY2xhc3M9XCJkZWxldGUtYnV0dG9uXCI+RGVsZXRlPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAuam9pbignXFxuJyl9XHJcbiAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgICBgO1xyXG4gIH0sXHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IFByb2R1Y3RMaXN0U2NyZWVuO1xyXG4iLCJjb25zdCBFcnJvcjQwNFNjcmVlbiA9IHtcclxuICAgIHJlbmRlcjogKCkgPT4gJzxkaXY+UGFnZSBub3QgRm91bmQ8L2Rpdj4nLFxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBFcnJvcjQwNFNjcmVlbjtcclxuIiwiaW1wb3J0IHsgc2lnbmluIH0gZnJvbSAnLi4vYXBpJztcclxuaW1wb3J0IHsgZ2V0VXNlckluZm8sIHNldFVzZXJJbmZvIH0gZnJvbSAnLi4vLi4vbG9jYWxTdG9yYWdlJztcclxuaW1wb3J0IHsgc2hvd0xvYWRpbmcsIGhpZGVMb2FkaW5nLCBzaG93TWVzc2FnZSwgcmVkaXJlY3RVc2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuY29uc3QgU2lnbmluU2NyZWVuID0ge1xyXG4gIGFmdGVyX3JlbmRlcjogKCkgPT4ge1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgLmdldEVsZW1lbnRCeUlkKCdzaWduaW4tZm9ybScpXHJcbiAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBhc3luYyAoZSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBzaG93TG9hZGluZygpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaWduaW4oe1xyXG4gICAgICAgICAgZW1haWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlbWFpbCcpLnZhbHVlLFxyXG4gICAgICAgICAgcGFzc3dvcmQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXNzd29yZCcpLnZhbHVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgIHNob3dNZXNzYWdlKGRhdGEuZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXRVc2VySW5mbyhkYXRhKTtcclxuICAgICAgICAgIHJlZGlyZWN0VXNlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfSxcclxuICByZW5kZXI6ICgpID0+IHtcclxuICAgIGlmIChnZXRVc2VySW5mbygpLm5hbWUpIHtcclxuICAgICAgcmVkaXJlY3RVc2VyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFxyXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XHJcbiAgICAgIDxmb3JtIGlkPVwic2lnbmluLWZvcm1cIj5cclxuICAgICAgICA8dWwgY2xhc3M9XCJmb3JtLWl0ZW1zXCI+XHJcbiAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgIDxoMT5TaWduLUluPC9oMT5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJlbWFpbFwiPkVtYWlsPC9sYWJlbD5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJlbWFpbFwiIG5hbWU9XCJlbWFpbFwiIGlkPVwiZW1haWxcIiAvPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInBhc3N3b3JkXCI+UGFzc3dvcmQ8L2xhYmVsPlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgbmFtZT1cInBhc3N3b3JkXCIgaWQ9XCJwYXNzd29yZFwiIC8+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cInByaW1hcnlcIj5TaWduaW48L2J1dHRvbj5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgTmV3IFVzZXI/XHJcbiAgICAgICAgICAgICAgPGEgaHJlZj1cIi8jL3JlZ2lzdGVyXCI+Q3JlYXRlIHlvdXIgYWNjb3VudCA8L2E+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICA8L3VsPlxyXG4gICAgICA8L2Zvcm0+XHJcbiAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfSxcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgU2lnbmluU2NyZWVuO1xyXG4iLCJpbXBvcnQgeyBnZXRVc2VySW5mbyB9IGZyb20gJy4uLy4uL2xvY2FsU3RvcmFnZSc7XHJcbmltcG9ydCB7IHBhcnNlUmVxdWVzdFVybCB9IGZyb20gJy4uL3V0aWxzJztcclxuXHJcbmNvbnN0IEhlYWRlciA9IHtcclxuICByZW5kZXI6ICgpID0+IHtcclxuICAgIGNvbnN0IHsgbmFtZSwgaXNBZG1pbiB9ID0gZ2V0VXNlckluZm8oKTtcclxuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHBhcnNlUmVxdWVzdFVybCgpO1xyXG4gICAgcmV0dXJuIGAgXHJcbiAgPGRpdiBjbGFzcz1cImJyYW5kXCI+XHJcbiAgICA8YnV0dG9uIGlkPVwiYXNpZGUtb3Blbi1idXR0b25cIj5cclxuICAgICAgJiM5Nzc2O1xyXG4gICAgPC9idXR0b24+XHJcbiAgICA8YSBocmVmPVwiLyMvXCI+Tml5YUNvbGxlY3Rpb25zPC9hPlxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJzZWFyY2hcIj5cclxuICA8Zm9ybSBjbGFzcz1cInNlYXJjaC1mb3JtXCIgIGlkPVwic2VhcmNoLWZvcm1cIj5cclxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJxXCIgaWQ9XCJxXCIgdmFsdWU9XCIke3ZhbHVlIHx8ICcnfVwiIC8+IFxyXG4gICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCI+PGkgY2xhc3M9XCJmYSBmYS1zZWFyY2hcIj48L2k+PC9idXR0b24+XHJcbiAgPC9mb3JtPiAgICAgICAgXHJcbiAgPC9kaXY+XHJcbiAgPGRpdj5cclxuICAke1xyXG4gICAgbmFtZVxyXG4gICAgICA/IGA8YSBocmVmPVwiLyMvcHJvZmlsZVwiPiR7bmFtZX08L2E+YFxyXG4gICAgICA6IGA8YSBocmVmPVwiLyMvc2lnbmluXCI+U2lnbi1JbjwvYT5gXHJcbiAgfSAgICBcclxuICAgICR7aXNBZG1pbiA/IGA8YSBocmVmPVwiLyMvcHJvZHVjdGxpc3RcIj5NYW5hZ2U8L2E+YCA6ICcnfVxyXG4gIDwvZGl2PmA7XHJcbiAgfSxcclxuICBhZnRlcl9yZW5kZXI6ICgpID0+IHtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZCgnc2VhcmNoLWZvcm0nKVxyXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgYXN5bmMgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoS2V5d29yZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxJykudmFsdWU7XHJcbiAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGAvP3E9JHtzZWFyY2hLZXl3b3JkfWA7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZCgnYXNpZGUtb3Blbi1idXR0b24nKVxyXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FzaWRlLWNvbnRhaW5lcicpLmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcclxuICAgICAgfSk7XHJcbiAgfSxcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xyXG4iLCJjb25zdCBBc2lkZSA9IHtcclxuICByZW5kZXI6IGFzeW5jICgpID0+IGBcclxuICAgPGRpdiBjbGFzcz1cImFzaWRlLWhlYWRlclwiPlxyXG4gICAgPGRpdj5TSE9QIEJZIENBVEVHT1JZPC9kaXY+XHJcbiAgICA8YnV0dG9uIGNsYXNzPVwiYXNpZGUtY2xvc2UtYnV0dG9uXCIgaWQ9XCJhc2lkZS1jbG9zZS1idXR0b25cIj54PC9idXR0b24+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImFzaWRlLWJvZHlcIj5cclxuICAgIDx1bCBjbGFzcz1cImNhdGVnb3JpZXNcIj5cclxuICAgICAgPGxpPlxyXG4gICAgICAgIDxhIGhyZWY9XCIvIy8/cT1OZWNrbGFjZVwiXHJcbiAgICAgICAgICA+TmVja2xhY2VcclxuICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1yaWdodFwiPjwvaT48L3NwYW4+XHJcbiAgICAgICAgPC9hPlxyXG4gICAgICA8L2xpPlxyXG4gICAgICA8bGk+XHJcbiAgICAgICAgPGEgaHJlZj1cIi8jLz9xPUJhbmdsZVwiXHJcbiAgICAgICAgICA+QmFuZ2xlc1xyXG4gICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLXJpZ2h0XCI+PC9pPjwvc3Bhbj5cclxuICAgICAgICA8L2E+XHJcbiAgICAgIDwvbGk+IFxyXG4gICAgICA8bGk+XHJcbiAgICAgICAgPGEgaHJlZj1cIi8jLz9xPUVhclJpbmdcIlxyXG4gICAgICAgICAgPkVhclJpbmdzXHJcbiAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWNoZXZyb24tcmlnaHRcIj48L2k+PC9zcGFuPlxyXG4gICAgICAgIDwvYT5cclxuICAgICAgPC9saT4gXHJcbiAgICA8L3VsPlxyXG4gIDwvZGl2PmAsXHJcbiAgYWZ0ZXJfcmVuZGVyOiBhc3luYyAoKSA9PiB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXNpZGUtY29udGFpbmVyJykuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgLmdldEVsZW1lbnRCeUlkKCdhc2lkZS1jbG9zZS1idXR0b24nKVxyXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FzaWRlLWNvbnRhaW5lcicpLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcclxuICAgICAgfSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFzaWRlO1xyXG4iLCJpbXBvcnQgSG9tZVNjcmVlbiBmcm9tICcuL3NjcmVlbnMvSG9tZVNjcmVlbic7XHJcbmltcG9ydCBQcm9kdWN0U2NyZWVuIGZyb20gJy4vc2NyZWVucy9Qcm9kdWN0U2NyZWVuJztcclxuaW1wb3J0IFByb2R1Y3RFZGl0U2NyZWVuIGZyb20gJy4vc2NyZWVucy9Qcm9kdWN0RWRpdFNjcmVlbic7XHJcbmltcG9ydCBQcm9kdWN0TGlzdFNjcmVlbiBmcm9tICcuL3NjcmVlbnMvUHJvZHVjdExpc3RTY3JlZW4nO1xyXG5pbXBvcnQgJy4uL3N0eWxlLmNzcydcclxuXHJcbmltcG9ydCB7IGhpZGVMb2FkaW5nLCBwYXJzZVJlcXVlc3RVcmwsIHNob3dMb2FkaW5nIH0gZnJvbSAnLi91dGlscyc7XHJcbmltcG9ydCBFcnJvcjQwNFNjcmVlbiBmcm9tICcuL3NjcmVlbnMvRXJyb3I0MDRTY3JlZW4nO1xyXG5pbXBvcnQgU2lnbmluU2NyZWVuIGZyb20gJy4vc2NyZWVucy9TaWduaW5TY3JlZW4nO1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vY29tcG9uZW50cy9IZWFkZXInO1xyXG5pbXBvcnQgQXNpZGUgZnJvbSAnLi9jb21wb25lbnRzL0FzaWRlJztcclxuXHJcblxyXG5jb25zdCByb3V0ZXMgPSB7XHJcbiAgICAnLyc6IEhvbWVTY3JlZW4sXHJcbiAgJy9wcm9kdWN0LzppZC9lZGl0JzogUHJvZHVjdEVkaXRTY3JlZW4sXHJcbiAgJy9wcm9kdWN0LzppZCc6IFByb2R1Y3RTY3JlZW4sXHJcbiAgJy9zaWduaW4nOiBTaWduaW5TY3JlZW4sXHJcbiAgJy9wcm9kdWN0bGlzdCc6IFByb2R1Y3RMaXN0U2NyZWVuLFxyXG4gXHJcbn07XHJcbmNvbnN0IHJvdXRlciA9IGFzeW5jICgpID0+IHtcclxuICAgIHNob3dMb2FkaW5nKCk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyc2VSZXF1ZXN0VXJsKCk7XHJcbiAgICBjb25zdCBwYXJzZVVybCA9IChyZXF1ZXN0LnJlc291cmNlID8gYC8ke3JlcXVlc3QucmVzb3VyY2V9YCA6ICcvJylcclxuICAgICAgICArIChyZXF1ZXN0LmlkID8gJy86aWQnIDogJycpXHJcbiAgICAgICAgKyAocmVxdWVzdC52ZXJiID8gYC8ke3JlcXVlc3QudmVyYn1gIDogJycpO1xyXG4gICAgY29uc3Qgc2NyZWVuID0gcm91dGVzW3BhcnNlVXJsXSA/IHJvdXRlc1twYXJzZVVybF0gOiBFcnJvcjQwNFNjcmVlbjtcclxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFkZXItY29udGFpbmVyJyk7XHJcbiAgIGhlYWRlci5pbm5lckhUTUwgPSBhd2FpdCBIZWFkZXIucmVuZGVyKCk7XHJcbiAgYXdhaXQgSGVhZGVyLmFmdGVyX3JlbmRlcigpOyBcclxuXHJcbiAgIGNvbnN0IGFzaWRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FzaWRlLWNvbnRhaW5lcicpO1xyXG4gIGFzaWRlLmlubmVySFRNTCA9IGF3YWl0IEFzaWRlLnJlbmRlcigpO1xyXG4gIGF3YWl0IEFzaWRlLmFmdGVyX3JlbmRlcigpOyBcclxuXHJcbiAgICBjb25zdCBtYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4tY29udGFpbmVyJyk7XHJcbiAgICBtYWluLmlubmVySFRNTCA9IGF3YWl0IHNjcmVlbi5yZW5kZXIoKTtcclxuICAgIGlmIChzY3JlZW4uYWZ0ZXJfcmVuZGVyKSBhd2FpdCBzY3JlZW4uYWZ0ZXJfcmVuZGVyKCk7XHJcbiAgICBoaWRlTG9hZGluZygpO1xyXG59O1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJvdXRlcik7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgcm91dGVyKTtcclxuIl0sIm5hbWVzIjpbImJpbmQiLCJmbiIsInRoaXNBcmciLCJ3cmFwIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwia2luZE9mIiwiY2FjaGUiLCJ0aGluZyIsInN0ciIsImNhbGwiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY3JlYXRlIiwia2luZE9mVGVzdCIsInR5cGUiLCJ0eXBlT2ZUZXN0IiwiaXNBcnJheSIsIkFycmF5IiwiaXNVbmRlZmluZWQiLCJpc0J1ZmZlciIsInZhbCIsImNvbnN0cnVjdG9yIiwiaXNGdW5jdGlvbiIsImlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsInJlc3VsdCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzT2JqZWN0IiwiaXNCb29sZWFuIiwiaXNQbGFpbk9iamVjdCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiaXRlcmF0b3IiLCJpc0RhdGUiLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0ZpbGVMaXN0IiwiaXNTdHJlYW0iLCJwaXBlIiwiaXNGb3JtRGF0YSIsInBhdHRlcm4iLCJGb3JtRGF0YSIsImlzVVJMU2VhcmNoUGFyYW1zIiwidHJpbSIsInJlcGxhY2UiLCJmb3JFYWNoIiwib2JqIiwiYWxsT3duS2V5cyIsImkiLCJsIiwibGVuZ3RoIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW4iLCJrZXkiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwiZXh0ZW5kIiwiYSIsImIiLCJzdHJpcEJPTSIsImNvbnRlbnQiLCJjaGFyQ29kZUF0IiwiaW5oZXJpdHMiLCJzdXBlckNvbnN0cnVjdG9yIiwicHJvcHMiLCJkZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJhc3NpZ24iLCJ0b0ZsYXRPYmplY3QiLCJzb3VyY2VPYmoiLCJkZXN0T2JqIiwiZmlsdGVyIiwicHJvcEZpbHRlciIsInByb3AiLCJtZXJnZWQiLCJlbmRzV2l0aCIsInNlYXJjaFN0cmluZyIsInBvc2l0aW9uIiwiU3RyaW5nIiwidW5kZWZpbmVkIiwibGFzdEluZGV4IiwiaW5kZXhPZiIsInRvQXJyYXkiLCJhcnIiLCJpc1R5cGVkQXJyYXkiLCJUeXBlZEFycmF5IiwiVWludDhBcnJheSIsImZvckVhY2hFbnRyeSIsImdlbmVyYXRvciIsIm5leHQiLCJkb25lIiwicGFpciIsIm1hdGNoQWxsIiwicmVnRXhwIiwibWF0Y2hlcyIsImV4ZWMiLCJwdXNoIiwiaXNIVE1MRm9ybSIsInRvQ2FtZWxDYXNlIiwicmVwbGFjZXIiLCJtIiwicDEiLCJwMiIsInRvVXBwZXJDYXNlIiwiaGFzT3duUHJvcGVydHkiLCJpc1JlZ0V4cCIsInJlZHVjZURlc2NyaXB0b3JzIiwicmVkdWNlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJyZWR1Y2VkRGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwibmFtZSIsImRlZmluZVByb3BlcnRpZXMiLCJmcmVlemVNZXRob2RzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwic2V0IiwiRXJyb3IiLCJ0b09iamVjdFNldCIsImFycmF5T3JTdHJpbmciLCJkZWxpbWl0ZXIiLCJkZWZpbmUiLCJzcGxpdCIsIm5vb3AiLCJ0b0Zpbml0ZU51bWJlciIsImRlZmF1bHRWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwiaGFzT3duUHJvcCIsInV0aWxzIiwiQXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiY29uZmlnIiwicmVxdWVzdCIsInJlc3BvbnNlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGFjayIsInRvSlNPTiIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwic3RhdHVzIiwiZnJvbSIsImVycm9yIiwiY3VzdG9tUHJvcHMiLCJheGlvc0Vycm9yIiwiY2F1c2UiLCJlbnZGb3JtRGF0YSIsImlzVmlzaXRhYmxlIiwicmVtb3ZlQnJhY2tldHMiLCJyZW5kZXJLZXkiLCJwYXRoIiwiZG90cyIsImNvbmNhdCIsIm1hcCIsImVhY2giLCJ0b2tlbiIsImpvaW4iLCJpc0ZsYXRBcnJheSIsInNvbWUiLCJwcmVkaWNhdGVzIiwidGVzdCIsImlzU3BlY0NvbXBsaWFudCIsImFwcGVuZCIsInRvRm9ybURhdGEiLCJmb3JtRGF0YSIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJtZXRhVG9rZW5zIiwiaW5kZXhlcyIsImRlZmluZWQiLCJvcHRpb24iLCJzb3VyY2UiLCJ2aXNpdG9yIiwiZGVmYXVsdFZpc2l0b3IiLCJfQmxvYiIsIkJsb2IiLCJ1c2VCbG9iIiwiY29udmVydFZhbHVlIiwidG9JU09TdHJpbmciLCJCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZWwiLCJpbmRleCIsImV4cG9zZWRIZWxwZXJzIiwiYnVpbGQiLCJwb3AiLCJlbmNvZGUiLCJjaGFyTWFwIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJBeGlvc1VSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsIl9wYWlycyIsImVuY29kZXIiLCJfZW5jb2RlIiwiYnVpbGRVUkwiLCJ1cmwiLCJzZXJpYWxpemVGbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJoYXNobWFya0luZGV4IiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiaGFuZGxlcnMiLCJ1c2UiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInN5bmNocm9ub3VzIiwicnVuV2hlbiIsImVqZWN0IiwiaWQiLCJjbGVhciIsImZvckVhY2hIYW5kbGVyIiwiaCIsInNpbGVudEpTT05QYXJzaW5nIiwiZm9yY2VkSlNPTlBhcnNpbmciLCJjbGFyaWZ5VGltZW91dEVycm9yIiwiVVJMU2VhcmNoUGFyYW1zIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJwcm9kdWN0IiwibmF2aWdhdG9yIiwid2luZG93IiwiZG9jdW1lbnQiLCJpc0Jyb3dzZXIiLCJjbGFzc2VzIiwicHJvdG9jb2xzIiwicGxhdGZvcm0iLCJkZWZhdWx0IiwidG9VUkxFbmNvZGVkRm9ybSIsImRhdGEiLCJoZWxwZXJzIiwiaXNOb2RlIiwicGFyc2VQcm9wUGF0aCIsImFycmF5VG9PYmplY3QiLCJmb3JtRGF0YVRvSlNPTiIsImJ1aWxkUGF0aCIsInRhcmdldCIsImlzTnVtZXJpY0tleSIsImlzTGFzdCIsImVudHJpZXMiLCJzZXR0bGUiLCJyZXNvbHZlIiwicmVqZWN0IiwidmFsaWRhdGVTdGF0dXMiLCJFUlJfQkFEX1JFUVVFU1QiLCJFUlJfQkFEX1JFU1BPTlNFIiwiTWF0aCIsImZsb29yIiwic3RhbmRhcmRCcm93c2VyRW52Iiwid3JpdGUiLCJleHBpcmVzIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwicmVhZCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsImJ1aWxkRnVsbFBhdGgiLCJyZXF1ZXN0ZWRVUkwiLCJtc2llIiwidXNlckFnZW50IiwidXJsUGFyc2luZ05vZGUiLCJjcmVhdGVFbGVtZW50Iiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsImhyZWYiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b2NvbCIsImhvc3QiLCJzZWFyY2giLCJoYXNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJjaGFyQXQiLCJsb2NhdGlvbiIsImlzVVJMU2FtZU9yaWdpbiIsInJlcXVlc3RVUkwiLCJwYXJzZWQiLCJDYW5jZWxlZEVycm9yIiwiRVJSX0NBTkNFTEVEIiwiX19DQU5DRUxfXyIsInBhcnNlUHJvdG9jb2wiLCJpZ25vcmVEdXBsaWNhdGVPZiIsInJhd0hlYWRlcnMiLCJwYXJzZXIiLCJsaW5lIiwic3Vic3RyaW5nIiwicGFyc2VIZWFkZXJzIiwiJGludGVybmFscyIsIiRkZWZhdWx0cyIsIm5vcm1hbGl6ZUhlYWRlciIsImhlYWRlciIsIm5vcm1hbGl6ZVZhbHVlIiwicGFyc2VUb2tlbnMiLCJ0b2tlbnMiLCJ0b2tlbnNSRSIsIm1hdGNoSGVhZGVyVmFsdWUiLCJjb250ZXh0IiwiZm9ybWF0SGVhZGVyIiwidyIsImNoYXIiLCJidWlsZEFjY2Vzc29ycyIsImFjY2Vzc29yTmFtZSIsIm1ldGhvZE5hbWUiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJjb25maWd1cmFibGUiLCJmaW5kS2V5IiwiX2tleSIsIkF4aW9zSGVhZGVycyIsImhlYWRlcnMiLCJkZWZhdWx0cyIsInZhbHVlT3JSZXdyaXRlIiwicmV3cml0ZSIsInNlbGYiLCJzZXRIZWFkZXIiLCJfdmFsdWUiLCJfaGVhZGVyIiwiX3Jld3JpdGUiLCJsSGVhZGVyIiwiZ2V0IiwiaGFzIiwibWF0Y2hlciIsImRlbGV0ZSIsImRlbGV0ZWQiLCJkZWxldGVIZWFkZXIiLCJub3JtYWxpemUiLCJmb3JtYXQiLCJub3JtYWxpemVkIiwiYXNTdHJpbmdzIiwiYWNjZXNzb3IiLCJpbnRlcm5hbHMiLCJhY2Nlc3NvcnMiLCJkZWZpbmVBY2Nlc3NvciIsInNwZWVkb21ldGVyIiwic2FtcGxlc0NvdW50IiwibWluIiwiYnl0ZXMiLCJ0aW1lc3RhbXBzIiwiaGVhZCIsInRhaWwiLCJmaXJzdFNhbXBsZVRTIiwiY2h1bmtMZW5ndGgiLCJzdGFydGVkQXQiLCJieXRlc0NvdW50IiwicGFzc2VkIiwicm91bmQiLCJjb29raWVzIiwidHJhbnNpdGlvbmFsRGVmYXVsdHMiLCJwcm9ncmVzc0V2ZW50UmVkdWNlciIsImxpc3RlbmVyIiwiaXNEb3dubG9hZFN0cmVhbSIsImJ5dGVzTm90aWZpZWQiLCJfc3BlZWRvbWV0ZXIiLCJlIiwibG9hZGVkIiwidG90YWwiLCJsZW5ndGhDb21wdXRhYmxlIiwicHJvZ3Jlc3NCeXRlcyIsInJhdGUiLCJpblJhbmdlIiwicHJvZ3Jlc3MiLCJlc3RpbWF0ZWQiLCJ4aHJBZGFwdGVyIiwiUHJvbWlzZSIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlcXVlc3REYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJyZXNwb25zZVR5cGUiLCJvbkNhbmNlbGVkIiwiY2FuY2VsVG9rZW4iLCJ1bnN1YnNjcmliZSIsInNpZ25hbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRDb250ZW50VHlwZSIsIlhNTEh0dHBSZXF1ZXN0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1bmVzY2FwZSIsImJ0b2EiLCJmdWxsUGF0aCIsIm9wZW4iLCJtZXRob2QiLCJwYXJhbXNTZXJpYWxpemVyIiwidGltZW91dCIsIm9ubG9hZGVuZCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVGV4dCIsInN0YXR1c1RleHQiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJlcnIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwic2V0VGltZW91dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIkVDT05OQUJPUlRFRCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIkVSUl9ORVRXT1JLIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsInRpbWVvdXRFcnJvck1lc3NhZ2UiLCJ0cmFuc2l0aW9uYWwiLCJFVElNRURPVVQiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ4c3JmQ29va2llTmFtZSIsInhzcmZIZWFkZXJOYW1lIiwic2V0UmVxdWVzdEhlYWRlciIsIm9uRG93bmxvYWRQcm9ncmVzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiY2FuY2VsIiwiYWJvcnQiLCJzdWJzY3JpYmUiLCJhYm9ydGVkIiwic2VuZCIsImh0dHBBZGFwdGVyIiwiYWRhcHRlcnMiLCJodHRwIiwieGhyIiwiZ2V0QWRhcHRlciIsIm5hbWVPckFkYXB0ZXIiLCJhZGFwdGVyIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJnZXREZWZhdWx0QWRhcHRlciIsInByb2Nlc3MiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlIiwidHJhbnNmb3JtUmVxdWVzdCIsImNvbnRlbnRUeXBlIiwiZ2V0Q29udGVudFR5cGUiLCJoYXNKU09OQ29udGVudFR5cGUiLCJpc09iamVjdFBheWxvYWQiLCJmb3JtU2VyaWFsaXplciIsIl9Gb3JtRGF0YSIsImVudiIsInRyYW5zZm9ybVJlc3BvbnNlIiwiSlNPTlJlcXVlc3RlZCIsInN0cmljdEpTT05QYXJzaW5nIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJjb21tb24iLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwidHJhbnNmb3JtRGF0YSIsImZucyIsInRyYW5zZm9ybSIsImlzQ2FuY2VsIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsInRocm93SWZSZXF1ZXN0ZWQiLCJkaXNwYXRjaFJlcXVlc3QiLCJ0aGVuIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsIm9uQWRhcHRlclJlamVjdGlvbiIsInJlYXNvbiIsIm1lcmdlQ29uZmlnIiwiY29uZmlnMSIsImNvbmZpZzIiLCJnZXRNZXJnZWRWYWx1ZSIsIm1lcmdlRGVlcFByb3BlcnRpZXMiLCJ2YWx1ZUZyb21Db25maWcyIiwiZGVmYXVsdFRvQ29uZmlnMiIsIm1lcmdlRGlyZWN0S2V5cyIsIm1lcmdlTWFwIiwiY29tcHV0ZUNvbmZpZ1ZhbHVlIiwiY29uZmlnVmFsdWUiLCJWRVJTSU9OIiwidmFsaWRhdG9ycyIsInZhbGlkYXRvciIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsInZlcnNpb24iLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJFUlJfREVQUkVDQVRFRCIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0T3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIkVSUl9CQURfT1BUSU9OX1ZBTFVFIiwiRVJSX0JBRF9PUFRJT04iLCJBeGlvcyIsImluc3RhbmNlQ29uZmlnIiwiaW50ZXJjZXB0b3JzIiwiY29uZmlnT3JVcmwiLCJib29sZWFuIiwiZnVuY3Rpb24iLCJkZWZhdWx0SGVhZGVycyIsImNsZWFuSGVhZGVyQ29uZmlnIiwicmVxdWVzdEludGVyY2VwdG9yQ2hhaW4iLCJzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMiLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwidW5zaGlmdCIsInJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsInByb21pc2UiLCJjaGFpbiIsIm5ld0NvbmZpZyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImdldFVyaSIsImdlbmVyYXRlSFRUUE1ldGhvZCIsImlzRm9ybSIsImh0dHBNZXRob2QiLCJDYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJfbGlzdGVuZXJzIiwib25mdWxmaWxsZWQiLCJzcGxpY2UiLCJjIiwic3ByZWFkIiwiY2FsbGJhY2siLCJpc0F4aW9zRXJyb3IiLCJwYXlsb2FkIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiaW5zdGFuY2UiLCJheGlvcyIsIkNhbmNlbCIsImFsbCIsInByb21pc2VzIiwiZm9ybVRvSlNPTiIsImFwaVVybCIsInN0YXJ0c1dpdGgiLCJzZXRVc2VySW5mbyIsIl9pZCIsImVtYWlsIiwiaXNBZG1pbiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJjbGVhclVzZXIiLCJyZW1vdmVJdGVtIiwiZ2V0VXNlckluZm8iLCJnZXRJdGVtIiwiZ2V0UHJvZHVjdHMiLCJzZWFyY2hLZXl3b3JkIiwicXVlcnlTdHJpbmciLCJsb2ciLCJnZXRQcm9kdWN0IiwiY3JlYXRlUHJvZHVjdCIsIkF1dGhvcml6YXRpb24iLCJkZWxldGVQcm9kdWN0IiwicHJvZHVjdElkIiwidXBkYXRlUHJvZHVjdCIsInVwbG9hZFByb2R1Y3RJbWFnZSIsInNpZ25pbiIsInVwZGF0ZSIsImdldFN1bW1hcnkiLCJzM1VwbG9hZCIsInBhcnNlUmVxdWVzdFVybCIsImFkZHJlc3MiLCJyIiwicSIsInJlc291cmNlIiwidmVyYiIsInJlcmVuZGVyIiwiY29tcG9uZW50IiwicmVuZGVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJhZnRlcl9yZW5kZXIiLCJzaG93TG9hZGluZyIsImNsYXNzTGlzdCIsImFkZCIsImhpZGVMb2FkaW5nIiwic2hvd01lc3NhZ2UiLCJyZWRpcmVjdFVzZXIiLCJIb21lU2NyZWVuIiwicHJvZHVjdHMiLCJpbWFnZSIsIlByb2R1Y3RTY3JlZW4iLCJyZXF1aXJlIiwiUHJvZHVjdEVkaXRTY3JlZW4iLCJwcmV2ZW50RGVmYXVsdCIsImNhdGVnb3J5IiwiZmlsZSIsImZpbGVzIiwiRGFzaGJvYXJkTWVudSIsInNlbGVjdGVkIiwiUHJvZHVjdExpc3RTY3JlZW4iLCJlZGl0QnV0dG9ucyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJlZGl0QnV0dG9uIiwiZGVsZXRlQnV0dG9ucyIsImRlbGV0ZUJ1dHRvbiIsImNvbmZpcm0iLCJFcnJvcjQwNFNjcmVlbiIsIlNpZ25pblNjcmVlbiIsIkhlYWRlciIsIkFzaWRlIiwicm91dGVzIiwicm91dGVyIiwicGFyc2VVcmwiLCJzY3JlZW4iLCJhc2lkZSIsIm1haW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///452\n')}},e=>{e(e.s=452)}]);